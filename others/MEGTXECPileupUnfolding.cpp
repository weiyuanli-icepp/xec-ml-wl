// Author: Rina Onda, Kensuke Yamamoto

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MEGTXECPileupUnfolding                                                     //
//                                                                            //
// Begin_Html <!--
/*-->

Description:
<p>

XEC pileup search and unfold by waveform sums.<br>
We have two switches for algorithm; One is for seed pulse detection and 
the other is for unfolding algorithms.<br>
<br>
Unfolding requires seed pulse references.
In case of no reference, pileup pulses are searched for by different time 
ranges. See FitAndUnfold function in source code.<br>
Active references can be switched on and off by users.
The switch implementation is as follows:
<ul>
  <li>1st digit: PMT differential waveform sum. 0: Inactive. 1: PMT 
signal time and MPPC/PMT charge are calculated. 2: PMT diff peak time and 
MPPC/PMT height are calculated.</li>
  <li>2nd digit: Deconvolution. 0: Inactive. 1: Active.</li>
  <li>3rd digit: Waveform sums clustered by PileupClustering. Analysis 
method selected in SP, ClusterAnalysis/Method. 0: Inactive. 1: Inner 
spatial distribution used. 2: Inner+Outer spatial distribution used.</li>
  <li>4th digit: FADC Qsum waveforms. 0: Inactive. 1: Active.</li>
  <li>5th digit: Method to input seed pulses to number of pulses used in 
fitting. 0: Seed pulses coincidence judged by constant window. 1: Seed 
pulses coincidence depending on reference.</li>
</ul>
<br>
Updates in 2023 are described in a technical note on EGamma 
reconstruction. TODO: link to TN.

</p>

<!--*/
// --> End_Html
//                                                                            //
// The event methods have been written by Rina Onda and Kensuke Yamamoto.     //
//                                                                            //
// Please note: The following information is only correct after executing     //
// the ROMEBuilder.                                                           //
//                                                                            //
// This task accesses the following folders :                                 //
//     EventHeader                                                            //
//     AUXWaveformAnalysisResult                                              //
//     BGOSumWaveform                                                         //
//     XECRunHeader                                                           //
//     XECPMRunHeader                                                         //
//     XECWFRunHeader                                                         //
//     XECPMCluster                                                           //
//     XECSumWaveform                                                         //
//     XECEnePMWeightResult                                                   //
//     XECFastRecResult                                                       //
//     XECPosLocalFitResult                                                   //
//     XECTimeFitResult                                                       //
//     XECPileupClusteringResult                                              //
//     XECPileupUnfoldingResult                                               //
//     XECPileupUnfoldingParameters                                           //
//     XECPileupMonitorPlots                                                  //
//     XECClusterInfo2                                                        //
//     TRGSimulationData                                                      //
//     TRGData                                                                //
//                                                                            //
//                                                                            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

/* Generated header file containing necessary includes                        */
#include "generated/MEGTXECPileupUnfoldingGeneratedIncludes.h"

////////////////////////////////////////////////////////////////////////////////
/*  This header was generated by ROMEBuilder. Manual changes above the        *
 * following line will be lost next time ROMEBuilder is executed.             */
/////////////////////////////////////----///////////////////////////////////////

#include "generated/MEGAnalyzer.h"
#include "tasks/MEGTXECPileupUnfolding.h"
#include "ROMEiostream.h"

#include <set>
#include <TVirtualFitter.h>
#include <TROOT.h>
#include <numeric>
#include <TSpectrum.h>
#include <TGraph.h>
#include <TParameter.h>
#include "xec/XECMakeSumWaveform.h"
#include "tasks/MEGTXEC.h"
#include "tasks/MEGTXECPileupClustering.h"
#include "units/MEGSystemOfUnits.h"
#include "constants/xec/xecconst.h"

using namespace MEG;

// uncomment if you want to include headers of all folders
//#include "MEGAllFolders.h"


ClassImp(MEGTXECPileupUnfolding)

namespace
{
std::vector<MEGTXECPileupUnfolding::SumWF*> fvTotalSumWF;
std::vector<MEGTXECPileupUnfolding::SumWF*> fvClusterSumWF;
std::vector<MEGTXECPileupUnfolding::SumWF*> fvSumWFTmpl;
std::vector<MEGTXECPileupUnfolding::TemplateWF*> fvTemplateWF;
std::vector<MEGTXECPileupUnfolding::DeconvWF*> fvDeconvWF;
std::vector<MEGTXECPileupUnfolding::ClusterGamma*> fvClusterGamma;
std::vector<MEGTXECPileupUnfolding::SeedGamma*> fvDiffGamma;
std::vector<MEGTXECPileupUnfolding::SeedGamma*> fvDeconvGamma;
std::vector<MEGTXECPileupUnfolding::SeedGamma*> fvFADCGamma;
std::vector<MEGTXECPileupUnfolding::RecGamma*> fvRecGamma;
Double_t kUncert_MIN = 5e-3;
const Double_t kTemplateT0 = 15 * MEG::nanosecond;
const Float_t  kConstantFraction = 0.05;
const Int_t    kFADCNBins   = 128;
const Double_t kFADCBinSize = 12.5 * MEG::nanosecond;
const Double_t kFADCTimeMin = -1600 * MEG::nanosecond;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::Init()
{
   if (!gAnalyzer->GetXECRunHeader()->GetNPM()) {
      return;
   }

   // Set verbose
   fDrawResult = (GetSP()->GetVerbose() / 100) % 10 > 0;
   fFitResult = (GetSP()->GetVerbose() / 10) % 10 > 0;
   fPrint = GetSP()->GetVerbose() % 10 > 0;

   /* ------------- Init SumWF object----------------*/
   for (Int_t i = 0; i < 2; i++) { // MPPC and PMT
      fvTotalSumWF.push_back(new SumWF(SumWF::kTotalSumWF, i, (i == 0),
                                       i == 0 ? fvTemplateType[TemplateWF::kSiPM] : fvTemplateType[TemplateWF::kPMT]));
      fvSumWFTmpl.push_back(new SumWF(SumWF::kTotalSumWF, i, (i == 0),
                                      i == 0 ? fvTemplateType[TemplateWF::kSiPM] : fvTemplateType[TemplateWF::kPMT], true));
   }
   if (GetSP()->GetDividedAnalysis()->GetActive()) {
      const Int_t sw = GetSP()->GetDividedAnalysis()->GetSwitch();
      TObjArray *divArray = GetSP()->GetDividedAnalysis()->GetType().Tokenize(",");
      const Int_t nDiv = divArray->GetEntries();
      for (Int_t i = 0; i < nDiv; i++) {
         TObjString *divStr = (TObjString*)divArray->At(i);
         Bool_t isSiPM = divStr->GetString().Contains(fvTemplateType[TemplateWF::kSiPM]);
         if (!isSiPM && !divStr->GetString().Contains(fvTemplateType[TemplateWF::kPMT])) {
            continue; // invalid
         }
         if (sw / kDivFitting % 10) {
            fvTotalSumWF.push_back(new SumWF(SumWF::kTotalSumWF, fvTotalSumWF.size(), isSiPM, divStr->GetString()));
         }
         if (sw / kDivMakeTemplate % 10) {
            fvSumWFTmpl.push_back(new SumWF(SumWF::kTotalSumWF, fvSumWFTmpl.size(), isSiPM, divStr->GetString(), true));
         }
      }
      delete divArray;
   }

   /* ------------- Init Draw object----------------*/
   fStyle = 0;
   if (fDrawResult) {
      fStyle = new TStyle();
      fStyle->SetOptStat(0);
      fStyle->SetOptTitle(0);
      fStyle->SetLabelSize(0.07, "xy");
      fStyle->SetTitleSize(0.06, "xy");
      fStyle->SetTitleOffset(1., "xy");
      fStyle->SetCanvasColor(10);
      fStyle->SetPadColor(10);
      fStyle->SetPadGridX(1);
      fStyle->SetPadGridY(1);
      fStyle->SetPadTickX(1);
      fStyle->SetPadTickY(1);
      fStyle->SetPadLeftMargin(0.2);
      fStyle->SetPadRightMargin(0.15);
      fStyle->SetPadTopMargin(0.05);
      fStyle->SetPadBottomMargin(0.2);
      fStyle->SetFrameFillColor(10);
      fCanvas = new TCanvas("cXECPLUF", "cXECPLUF", 1200, 600);
      fCanvas->Divide(2, 1);
      if (GetSP()->GetMode() == kMakeTemplate) {
         fCanvas->Divide(2, 2);
      }
   }

   /* ------------- Read Trigger Mask----------------*/
   fTRGMask.clear();
   TObjArray *maskArray = GetSP()->GetTRGMask().Tokenize(",");
   if (!maskArray->GetEntries()) {
      maskArray = gAnalyzer->GetXECTask()->GetSP()->GetTRGMask().Tokenize(",");
   }
   for (Int_t iMask = 0; iMask < maskArray->GetEntries(); iMask++) {
      TObjString *mask = (TObjString*)maskArray->At(iMask);
      fTRGMask.push_back(static_cast<Short_t>(mask->GetString().Atoi()));
   }
   delete maskArray;

   fFixParamTRGMask.clear();
   TObjArray *maskArray2 = GetSP()->GetFixParamTRGMask().Tokenize(",");
   for (Int_t iMask = 0; iMask < maskArray2->GetEntries(); iMask++) {
      TObjString *mask = (TObjString*)maskArray2->At(iMask);
      fFixParamTRGMask.push_back(static_cast<Short_t>(mask->GetString().Atoi()));
   }
   delete maskArray2;

   /* ------------- Prepare TemplateFit----------------*/
   if (GetSP()->GetReferenceSwitch() / kDeconvGamma % 10) {
      if (PrepareTemplateFit() != 1) {
         Report(R_WARNING, "Failed to read TemplateFit. Turn off doconvolution.");
         Int_t sw = GetSP()->GetReferenceSwitch();
         sw = (kDeconvGamma / 10 ? sw % (kDeconvGamma / 10) : 0)
              + sw / (kDeconvGamma * 10) * kDeconvGamma * 10;
         GetSP()->SetReferenceSwitch(sw);
      }
   }

   /* ------------- Prepare chi2 waveform for simultaneous fit ----------------*/
   fgChi2Waveform = new MEGXECDRSWaveform();

   /* ------------- Prepare waveforms for monitor ----------------*/
   auto pPlot = gAnalyzer->GetXECPileupMonitorPlots();
   pPlot->SetTotalSumWaveformSize(2);
   pPlot->SetFitSumWaveformSize(2);
   pPlot->SetMainSumWaveformSize(2);
   pPlot->SetChi2SumWaveformSize(3); // MPPC, PMT, Sum
   pPlot->SetDifferentialWaveformSize(2);
   pPlot->SetFADCQsumWaveformSize(2);
   pPlot->SetDiffWFScaleSize(2);
   for (auto sumwf : fvTotalSumWF) {
      Int_t iSumWF = 0;
      if (!sumwf->fIsSiPM) {
         iSumWF = 1;
      }
      sumwf->fSumWaveform      = pPlot->GetTotalSumWaveformAt(iSumWF);
      sumwf->fFitWaveform      = pPlot->GetFitSumWaveformAt(iSumWF);
      sumwf->fMainWaveform     = pPlot->GetMainSumWaveformAt(iSumWF);
      sumwf->fChi2Waveform     = pPlot->GetChi2SumWaveformAt(iSumWF);
      sumwf->fDiffWaveform     = pPlot->GetDifferentialWaveformAt(iSumWF);
      sumwf->fFADCQsumWaveform = pPlot->GetFADCQsumWaveformAt(iSumWF);
   }
   fgChi2Waveform = pPlot->GetChi2SumWaveformAt(2);
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::BeginOfRun()
{
   UpdateParametersFromSP();
   PrepareTemplate();

   std::vector<std::vector<SumWF*> > vvSumWF = {fvTotalSumWF, fvSumWFTmpl};
   const Int_t nPM = gAnalyzer->GetXECRunHeader()->GetNPM();

   // Assign PMs
   MEGXECPMRunHeader *pmrh;
   for (Int_t iPM = 0; iPM < nPM; iPM++) {
      pmrh = gAnalyzer->GetXECPMRunHeaderAt(iPM);

      for (auto vSumWF : vvSumWF) {
         for (auto sumwf : vSumWF) {
            if (pmrh->GetIsSiPM()
                && sumwf->fType == fvTemplateType[TemplateWF::kSiPM]) {
               sumwf->fvPM.push_back(iPM);
            } else if (!pmrh->GetIsSiPM()
                       && sumwf->fType == fvTemplateType[TemplateWF::kPMT]) {
               sumwf->fvPM.push_back(iPM);
            } else if (pmrh->GetIsSiPM()
                       && pmrh->GetProductionLot() == 'A'
                       && sumwf->fType == fvTemplateType[TemplateWF::kSiPMLotA]) {
               sumwf->fvPM.push_back(iPM);
            } else if (pmrh->GetIsSiPM()
                       && pmrh->GetProductionLot() == 'B'
                       && sumwf->fType == fvTemplateType[TemplateWF::kSiPMLotB]) {
               sumwf->fvPM.push_back(iPM);
            } else if (pmrh->GetIsSiPM()
                       && pmrh->GetProductionLot() == 'C'
                       && sumwf->fType == fvTemplateType[TemplateWF::kSiPMLotC]) {
               sumwf->fvPM.push_back(iPM);
            } else if (pmrh->GetIsSiPM()
                       && pmrh->GetProductionLot() == 'D'
                       && sumwf->fType == fvTemplateType[TemplateWF::kSiPMLotD]) {
               sumwf->fvPM.push_back(iPM);
            }
         } // end of sumwf loop
      } // end of vSumWF loop
   } // end of PM loop

   // Set FADC Qsum waveform
   if (gAnalyzer->GetXECPileupUnfoldingParameters()->GetReferenceSwitch() / kFADCGamma % 10) {
      fvFADCQsumWaveform.resize(2);
      if (gAnalyzer->IsActiveDAQ("bartender")) {
         fvFADCQsumWaveform[0] = gAnalyzer->GetTRGSimulationData()->GetQSUMMppcSimWaveform();
         fvFADCQsumWaveform[1] = gAnalyzer->GetTRGSimulationData()->GetQSUMPmtSimWaveform();
      } else {
         fvFADCQsumWaveform[0] = gAnalyzer->GetTRGData()->GetQSUMMppcWaveform();
         fvFADCQsumWaveform[1] = gAnalyzer->GetTRGData()->GetQSUMPmtWaveform();
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::Event()
{
   // Perform analysis specified in GetSP()->GetMode().
   // Mode  0: Pileup analysis.
   // Mode 10: Make template. If some template is read, new template is created from the events without pileup.
   // (i.e. Template can be made iteratively from the data with pileups).

   /*------------- Clear previous event. ----------------*/
   gAnalyzer->SetXECPileupUnfoldingResultSize(0);
   Release();
   for (auto sumwf : fvTotalSumWF) {
      sumwf->Clear();
   }
   if (fDrawResult) {
      //fCanvas->Clear();
      for (auto c : fvTotalSumWFCanvas) {
         c->Clear("D");
      }
      for (auto c : fvClusterSumWFCanvas) {
         c->Clear("D");
         c->Flush();
      }
   }

   /*------------- Check if analysis is done. ----------------*/
   if (fvTemplateWF.size() < 2) {
      Report(R_ERROR, "Template waveforms are not found. Need two at least.");
      return;
   }
   if (!EventSelection()) {
      return;
   }

   if (fPrint || fDrawResult) {
      printf("____________________________________________________\n");
      printf("Start event %d.\n", static_cast<Int_t>(gAnalyzer->GetCurrentEventNumber()));
   }

   MEGXECPileupUnfoldingParameters* pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();
   fgRefTime = GetReferenceTime();

   /*------------- Read results from PileupClustering --------------*/
   if (pParameters->GetReferenceSwitch() / kClusterGamma % 10) {
      ReadPileupClusteringResult();
      FindMainGammaCluster(static_cast<Short_t>(pParameters->GetReferenceSwitch() / kClusterGamma % 10));
      InvalidateUnusedClusterGamma(static_cast<Short_t>(pParameters->GetReferenceSwitch() / kClusterGamma % 10));
      if (gAnalyzer->IsROMEAndARGUS()) { // if program mode is 2
         SetClusterWaveformsPointer();
      }
      if (fPrint) {
         for (auto gamma : fvClusterGamma) {
            gamma->Print();
         }
      }
   }

   /*------------- Make SumWF ----------------*/
   for (auto sumwf : fvTotalSumWF) {
      sumwf->fRefTime = fgRefTime;
      sumwf->MakeSumWF();
   }
   for (auto sumwf : fvClusterSumWF) {
      if (sumwf->fRefTime > 0) {
         sumwf->fRefTime = fgRefTime;
      }
      sumwf->MakeSumWF();
   }

   /*--------- Analyze SumWF. ---------*/
   if (pParameters->GetReferenceSwitch() / kDiffGamma % 10) {
      AnalyzeDiffWF(static_cast<Short_t>(pParameters->GetReferenceSwitch() / kDiffGamma % 10));
   }
   if (pParameters->GetReferenceSwitch() / kDeconvGamma % 10) {
      AnalyzeDeconvWF();
   }
   if (pParameters->GetReferenceSwitch() / kClusterGamma % 10) {
      AnalyzeClusterWF();
   }
   if (pParameters->GetReferenceSwitch() / kFADCGamma % 10) {
      AnalyzeFADCWF();
   }
   AnalyzeTotalWF();

   /*--------- Output Result. ---------*/
   FillResult();
   if (fDrawResult) {
      DrawWaveform();
   }

   /*--------- Make template. ---------*/
   if (GetSP()->GetMode() == kMakeTemplate &&
       gAnalyzer->GetXECPileupUnfoldingResultSize() == 1 &&
       gAnalyzer->GetXECPileupUnfoldingResultAt(0)->Getevstat() == kNoPileup) {
      MakeTemplate();
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::EndOfRun()
{
   Release();
   for (auto sumwf : fvTotalSumWF) {
      sumwf->fvPM.clear();
   }
   for (auto sumwf : fvSumWFTmpl) {
      sumwf->fvPM.clear();
   }
   if (gAnalyzer->GetXECPileupUnfoldingParameters()->GetReferenceSwitch() / kFADCGamma % 10) {
      fvFADCQsumWaveform.clear();
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::Terminate()
{
   // Record generated waveform template.
   if (GetSP()->GetMode() == kMakeTemplate) {
      TFile *fout = new TFile(Form("XECWFTemplateUF_%05d.root", static_cast<Int_t>(gAnalyzer->GetCurrentRunNumber())), "RECREATE");
      Double_t samplingInterval = gAnalyzer->GetXECRunHeader()->GetSamplingInterval();
      TParameter<Double_t>* par_samplingInterval = new TParameter<Double_t>("samplingInterval", samplingInterval);
      par_samplingInterval->Write();

      for (auto wf : fvSumWFTmpl) {
         wf->fTemplateWF->fTemplate->Write(Form("XECSumWFTemplate_%d", wf->fIndex));
      }
      for (auto wf : fvSumWFTmpl) {
         XECMakeTemplate::End(fout, 2, wf->fTemplateWF->fTemplateWaveform, wf->fTemplateWF->fNAdded);
      }

      fout->Close();
      delete par_samplingInterval;
      delete fout;
   }

   if (fStyle) {
      delete fStyle;
   }
   if (fCanvas) {
      delete fCanvas;
   }
   for (auto c : fvTotalSumWFCanvas) {
      delete c;
   }
   for (auto c : fvClusterSumWFCanvas) {
      delete c;
   }
   for (auto sumwf : fvTotalSumWF) {
      // sumwf->Clear("D");
      delete sumwf;
   }
   for (auto sumwf : fvSumWFTmpl) {
      sumwf->Clear("D");
   }
   for (auto sumwf : fvTemplateWF) {
      sumwf->Clear("D");
   }
   fvTotalSumWF.clear();
   fvSumWFTmpl.clear();
   fvTemplateWF.clear();

}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::MakeSumWF(void)
{
   // Make sum waveform of each event using selected weight, Qsum2Weight or EnePMWeight.
   // Waveform timing is shifted.

   if (!fvPM.size()) {
      return;
   }

   const Int_t nPM = gAnalyzer->GetXECRunHeader()->GetNPM();
   std::vector<Int_t> vBadCh;
   fvSaturatedCh.clear();
   fvDeadCh.clear();
   for (auto pm : fvPM) {
      Int_t iCluster = gAnalyzer->GetXECClusterInfo2At(pm)->Getclusterid();
      if (gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetSaturationCorrection()->GetActive()
          && gAnalyzer->GetXECPMClusterAt(iCluster)->GetsaturatedAt(0)) {
         vBadCh.push_back(pm);
         fvSaturatedCh.push_back(pm);
      }
      if (gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetDeadChannelRecovery()->GetActive()
          && gAnalyzer->GetXECPMRunHeaderAt(pm)->GetIsBad()) {
         vBadCh.push_back(pm);
         fvDeadCh.push_back(pm);
      }
   }

   /* ------------- Make SumWF----------------*/
   XECMakeSumWaveform::InitSumWaveform(fSumWaveform);

   // Delay
   std::vector<Double_t> vTdelay(nPM, 0.);
   if (gAnalyzer->GetXECTimeFitResultSize() > 0) {
      MEGXECTimeFitResult *pTimeFit = gAnalyzer->GetXECTimeFitResultAt(0);
      if (pTimeFit->GettdelaySize() > 0) {
         for (auto pm : fvPM) {
            vTdelay[pm] = pTimeFit->GettdelayAt(pm);
         }
      }
   }

   // Weight
   std::vector<Float_t> vWeight(nPM, 0.);
   Option_t *option;
   switch (gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetWeightSwitch()) {
   case kQsum2Weight:
   default:
      for (auto pm : fvPM) {
         vWeight[pm] = 1;
      }
      for (auto pm : vBadCh) {
         vWeight[pm] = 0;
      }
      option = "TCORR2";
      break;

   case kEnePMWeight:
      if (!gAnalyzer->GetXECEnePMWeightResultSize()) {
         Report(R_WARNING, "No EnePMWeight results. Qsum2Weight is used.");
         for (auto pm : fvPM) {
            vWeight[pm] = 1;
         }
         option = "TCORR2";
      } else {
         for (auto pm : fvPM) {
            vWeight[pm] = GetEnePMWeight(pm);
         }
         option = "TCORR";
      }
      for (auto pm : vBadCh) {
         vWeight[pm] = 0; // saturated or dead channels
      }
      break;
   }

   XECMakeSumWaveform::MakeSumWaveformArbWeight(fSumWaveform, vWeight, vTdelay, option);

   /* ------------- Shift t0 ----------------*/
   fSumWaveform->TimeShift(-fRefTime);

   /* ------------- Resample----------------*/
   Double_t binSize = gAnalyzer->GetXECRunHeader()->GetSamplingInterval();
   MEGDRSWaveform *wforg = new MEGDRSWaveform(*fSumWaveform);
   Int_t nbin_startmargin = 30;
   wforg->Sampling(fSumWaveform->GetNPoints() - 60,
                   fSumWaveform->GetTimeMin() + binSize * nbin_startmargin,
                   binSize, fSumWaveform, "precise");
   delete wforg;

   /* ------------- Baseline correction----------------*/
   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1);
   Double_t baseline = 0;
   Double_t baseline_tmp = -1e10;
   Double_t tstart, tend;
   tstart = TMath::Max(wfrh->GetBaselineStart(),
                       fSumWaveform->GetTimeMin() + 15 * MEG::nanosecond);
   tend = wfrh->GetBaselineEnd();
   if (tstart < tend) {
      baseline_tmp = fSumWaveform->CalculateBaseline(tstart, tend);
   }
   tend = fSumWaveform->GetTimeMax() - 10 * MEG::nanosecond;
   tstart = tend - (wfrh->GetBaselineEnd() - wfrh->GetBaselineStart());
   if (tstart < tend) {
      baseline = TMath::Max(baseline_tmp, fSumWaveform->CalculateBaseline(tstart, tend));
   }
   *fSumWaveform -= baseline;

   /* ------------- Normalization parameter calculation ----------------*/
   Double_t chargeIntShift = -30 * MEG::nanosecond;
   Double_t amplitude = fSumWaveform->MinimumPeak(TMath::Max(wfrh->GetChargeIntStart() + chargeIntShift, fSumWaveform->GetTimeMin()),
                                                  TMath::Min(wfrh->GetChargeIntEnd() + chargeIntShift, fSumWaveform->GetTimeMax()));
   fNormCharge = 1.;
   if (amplitude == 0) {
      *fSumWaveform *= 0;
   } else {
      if (fTemplateWF->fTemplateMean.size()) {
         fNormCharge = -std::accumulate(fTemplateWF->fTemplateMean.begin(),
                                        fTemplateWF->fTemplateMean.end(), 0.)
                       * fTemplateWF->fSamplingInterval / kDRSInputImpedance;
      }
   }

   /* ------------- Differentiate----------------*/
   fDiffWaveform->SetNPoints(fSumWaveform->GetNPoints());
   MEGXECDRSWaveform* wftmp = new MEGXECDRSWaveform(fSumWaveform->GetNPoints());
   Int_t mva = gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetDifferentiation()->GetMovingAverage();
   const Int_t diffPnt = gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetDifferentiation()->GetNPoints();
   if (mva > 0 && mva % 2 == 1) {
      fSumWaveform->MovingAverage(mva, wftmp, 0, fSumWaveform->GetNPoints());
   } else {
      wftmp = fSumWaveform;
   }
   if (diffPnt > 1) {
      wftmp->Differentiate(diffPnt, fDiffWaveform);
   } else {
      *fDiffWaveform = *wftmp;
   }
   Double_t peak;
   Int_t pkpoint;
   fDiffWaveform->MinimumPeak(peak, pkpoint,
                              wfrh->GetChargeIntStart() + chargeIntShift, wfrh->GetChargeIntEnd() + chargeIntShift);
   *fDiffWaveform *= 1 / (TMath::Abs(peak) + 1e-12);
   if (fID == kTotalSumWF) {
      gAnalyzer->GetXECPileupMonitorPlots()->SetDiffWFScaleAt(fIsSiPM ? 0 : 1, -amplitude);
   }

   /* ------------- MovingAverage ----------------*/
   mva = gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetMovingAverage()->GetNPoints();
   fSumWaveform->MovingAverage(mva, fMVAWaveform, 0, fSumWaveform->GetNPoints(), true, true);
   delete wftmp;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::FitSumWF(const std::vector<Double_t>& FitRange, const Bool_t kPrint, const Bool_t kReject)
{
   // Fit a sum waveform.
   // Init value for fitting should be given by fvPulse.
   // Result will be over written also on fvPulse.

   const Int_t nGamma = fvPulse.size();
   Int_t nPar = 5 + 3 * nGamma;
   const Int_t startpnt = fSumWaveform->FindPoint(FitRange[0]) + 1;
   const Int_t endpnt   = fSumWaveform->FindPoint(FitRange[1]) + 1;

   // Init Minuit.
   TVirtualFitter::SetDefaultFitter("Minuit");
   Double_t arglist[10];
   Int_t    ierflg = 0;
   Double_t edm, errdef, fcn;
   Int_t    nvpar, nparx, icstat;
   if (fMinuit && fMinuit->GetNumPars() != nPar) {
      delete fMinuit;
      fMinuit = 0;
   }
   if (!fMinuit) {
      fMinuit = new TMinuit(nPar);
      fMinuit->SetFCN(FCN);
      if (!kPrint) {
         fMinuit->SetPrintLevel(-1);
      }
      fMinuit->mnexcm("SET NOW", arglist, 0, ierflg);
      arglist[0] = 1;
      fMinuit->mnexcm("SET ERR", arglist, 1, ierflg); // UP = 1 : normal chisquare fit
      arglist[0] = 1;
      fMinuit->mnexcm("SET STR", arglist, 1, ierflg); // normal
   }

   // Set Parameters.
   fMinuit->mnparm(0, "Switch", fID, 0, fID, fID, ierflg);
   fMinuit->mnparm(1, "WFIndex", fIndex, 0, fIndex, fIndex, ierflg);
   fMinuit->mnparm(2, "RangeUL", startpnt, 0, startpnt, startpnt, ierflg);
   fMinuit->mnparm(3, "RangeLL", endpnt, 0, endpnt, endpnt, ierflg);
   fMinuit->mnparm(4, "NGamma", nGamma, 0, nGamma, nGamma, ierflg);
   fMinuit->FixParameter(0);
   fMinuit->FixParameter(1);
   fMinuit->FixParameter(2);
   fMinuit->FixParameter(3);
   fMinuit->FixParameter(4);
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      auto thisPulse = fvPulse[iGamma];
      fMinuit->mnparm(5 + iGamma * 3, "Scale", thisPulse->fE, thisPulse->fEUncert / 5.,
                      TMath::Max(0., thisPulse->fE - 5 * thisPulse->fEUncert),
                      thisPulse->fE + 5 * thisPulse->fEUncert, ierflg);
      fMinuit->mnparm(6 + iGamma * 3, "Timing", thisPulse->fT,
                      thisPulse->fTUncert / 5.,
                      TMath::Max(thisPulse->fT - 5 * thisPulse->fTUncert, fSumWaveform->GetTimeMin() - 100 * MEG::nanosecond), // pulse < -200 nanosecond is not allowed.
                      TMath::Min(thisPulse->fT + 5 * thisPulse->fTUncert, FitRange[1]), ierflg);
      fMinuit->mnparm(7 + iGamma * 3, "Baseline", thisPulse->fBase, thisPulse->fBaseUncert / 5.,
                      thisPulse->fBase - 5 * thisPulse->fBaseUncert,
                      thisPulse->fBase + 5 * thisPulse->fBaseUncert, ierflg);
      if (iGamma != 0) {
         fMinuit->FixParameter(7 + iGamma * 3);
      }
   }

   // execute MIGRAD minimization
   arglist[0] = 2000;
   arglist[1] = 0.1;
   fMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
   fMinuit->mnstat(fcn, edm, errdef, nvpar, nparx, icstat);
   if (kPrint) {
      fMinuit->mnprin(3, fcn);
   }
   if (kPrint) {
      printf("%d Gamma Fit. Chi2 NDF : %.1lf.\n", nGamma, fcn);
   }

   if (kReject) {
      // Recalculate in all range
      Double_t gin[nPar], par[nPar], par_err[nPar];
      for (Int_t iPar = 0; iPar < nPar; iPar++) {
         fMinuit->GetParameter(iPar, par[iPar], par_err[iPar]);
      }
      par[2] = 0;
      par[3] = fSumWaveform->GetNPoints() - 1;
      FCN(nPar, gin, fcn, par, 0);
      if (fFCN > fcn) {
         fFCN = fcn;
      } else { // reject the new pulse candidate
         delete fvPulse.back();
         fvPulse.pop_back();
         return;
      }
   } else {
      fFCN = fcn;
   }

   // Fill result.
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      fMinuit->GetParameter(5 + iGamma * 3, fvPulse[iGamma]->fE, fvPulse[iGamma]->fEUncert);
      fMinuit->GetParameter(6 + iGamma * 3, fvPulse[iGamma]->fT, fvPulse[iGamma]->fTUncert);
      fMinuit->GetParameter(7 + iGamma * 3, fvPulse[iGamma]->fBase, fvPulse[iGamma]->fBaseUncert);
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::UpdateFitWaveforms()
{
   // Create waveform for fitted pulses.
   // Total fitted waveform is updated.
   // Refer to FCN() for definition of par.

   fFitWaveform->SetTime(fSumWaveform);
   fFitWaveform->ResetAmplitude();
   for (auto pulse : fvPulse) {
      SafeDelete(pulse->fFitWaveform);
      pulse->fFitWaveform = new MEGXECDRSWaveform();
      pulse->fFitWaveform->SetTime(fSumWaveform);

      Double_t par[3] = {pulse->fE, pulse->fT, pulse->fBase};
      for (Int_t iPnt = 0; iPnt < fSumWaveform->GetNPoints(); iPnt++) {
         pulse->fFitWaveform->SetAmplitudeAt(iPnt, GetExpAmplAt(iPnt, par));
      //}
      //for (Int_t iPnt = 0; iPnt < fSumWaveform->GetNPoints(); iPnt++) {
         fFitWaveform->AddAmplitudeAt(iPnt, pulse->fFitWaveform->GetAmplitudeAt(iPnt));
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::UpdateChi2Waveform()
{
   // Update chi2 waveform.
   // Refer to FCN() for definition of par.

   fChi2Waveform->SetNPoints(0);
   fChi2Waveform->SetTime(fSumWaveform);

   Double_t par[5 + 3 * fvPulse.size()];
   par[0] = fID;
   par[1] = fIndex;
   par[2] = 0;
   par[3] = 0;
   par[4] = fvPulse.size();
   for (Int_t iGamma = 0; iGamma < par[4]; iGamma++) {
      par[5 + iGamma * 3] = fvPulse[iGamma]->fE;
      par[6 + iGamma * 3] = fvPulse[iGamma]->fT;
      par[7 + iGamma * 3] = fvPulse[iGamma]->fBase;
   }
   for (Int_t iPnt = 0; iPnt < fSumWaveform->GetNPoints(); iPnt++) {
      fChi2Waveform->SetAmplitudeAt(iPnt, GetChi2At(iPnt, par));
   }

   if (gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2Switch() == 0) {
      fChi2Waveform->MovingAverage(5);
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::UpdateResWaveform()
{
   // Update residual waveform which is raw waveform - total fitted waveform.
   // Refer to FCN() for definition of par.

   fResWaveform->SetNPoints(0);
   fResWaveform->SetTime(fSumWaveform);

   Double_t par[5 + 3 * fvPulse.size()];
   par[0] = fID;
   par[1] = fIndex;
   par[2] = 0;
   par[3] = 0;
   par[4] = fvPulse.size();
   for (Int_t iGamma = 0; iGamma < par[4]; iGamma++) {
      par[5 + iGamma * 3] = fvPulse[iGamma]->fE;
      par[6 + iGamma * 3] = fvPulse[iGamma]->fT;
      par[7 + iGamma * 3] = fvPulse[iGamma]->fBase;
   }
   for (Int_t iPnt = 0; iPnt < fSumWaveform->GetNPoints(); iPnt++) {
      fResWaveform->SetAmplitudeAt(iPnt, GetResAt(iPnt, par));
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInChi2(const std::vector<Double_t>& peakSearchWindow,
                                                     std::map<Double_t, Int_t, std::greater<Double_t>>& vPeak, Double_t /*threshold*/)
{
   // Peak search in given time region.
   // Result filled in vPeak<amplitude, point>.
   // Amplitude ordered.

   const Double_t kThreshold = gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2PeakThreshold();

   // const Int_t startPnt = 0;
   // if (threshold < 0) {
   //    const Int_t nPnt = 50;
   //    threshold = TMath::Mean(nPnt, fChi2Waveform->GetAmplitude() + startPnt);
   //    threshold = TMath::Min(threshold, TMath::Mean(nPnt, fChi2Waveform->GetAmplitude() + fChi2Waveform->GetNPoints() - startPnt - nPnt));
   //    threshold *= gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2Threshold();
   //    threshold = TMath::Max(threshold, kThreshold);
   // }
   // fChi2Threshold = threshold;
   fChi2Threshold = kThreshold;

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   Int_t nPeak = fChi2Waveform->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                           TMath::Max(peakSearchWindow[0], fChi2Waveform->GetTimeAt(2)),
                                           TMath::Min(peakSearchWindow[1], fChi2Waveform->GetTimeAt(fChi2Waveform->GetNPoints() - 3)),
                                           fChi2Threshold, 4, 1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   vPeak.clear();
   for (Int_t i = 0; i < nPeak; i++) {
      vPeak[vAmpl[i]] = vPnt[i];
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInChi2(const std::vector<Double_t>& peakSearchWindow,
                                                     std::map<Int_t, Double_t>& vPeak, Double_t /*threshold*/)
{
   // Peak search in given time region.
   // Result filled in vPeak<point, amplitude>.
   // Point (timing) ordered.

   const Double_t kThreshold = gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2PeakThreshold();

   // const Int_t startPnt = 0;
   // if (threshold < 0) {
   //    const Int_t nPnt = 50;
   //    threshold = TMath::Mean(nPnt, fChi2Waveform->GetAmplitude() + startPnt);
   //    threshold = TMath::Min(threshold, TMath::Mean(nPnt, fChi2Waveform->GetAmplitude() + fChi2Waveform->GetNPoints() - startPnt - nPnt));
   //    threshold *= gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2Threshold();
   //    threshold = TMath::Max(threshold, kThreshold);
   // }
   // fChi2Threshold = threshold;
   fChi2Threshold = kThreshold;

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   Int_t nPeak = fChi2Waveform->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                           TMath::Max(peakSearchWindow[0], fChi2Waveform->GetTimeAt(2)),
                                           TMath::Min(peakSearchWindow[1], fChi2Waveform->GetTimeAt(fChi2Waveform->GetNPoints() - 3)),
                                           fChi2Threshold, 4, 1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   vPeak.clear();
   for (Int_t i = 0; i < nPeak; i++) {
      vPeak[vPnt[i]] = vAmpl[i];
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInDiff(const std::vector<Double_t>& peakSearchWindow,
                                                     std::map<Double_t, Int_t, std::less<Double_t>>& vPeak, Double_t threshold)
{
   // Peak search in given time region.
   // Result filled in vPeak<amplitude, point>.
   // Amplitude ordered.

   fPeakSearchMethod = kSearchInDiff;

   const Int_t mva = gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetDifferentiation()->GetMovingAverage();
   const Int_t diffPnt = gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetDifferentiation()->GetNPoints();
   const Int_t startPnt = (diffPnt + mva) / 2 + 1;
   
   // Threshold scaled by noise RMS
   if (threshold > 0) {
      const Int_t nPnt = 50;
      Float_t rms = 0;
      rms = fDiffWaveform->CalculateRMS(fDiffWaveform->GetTimeAt(startPnt), fDiffWaveform->GetTimeAt(startPnt + nPnt));
      threshold = TMath::Sqrt(rms / nPnt);
      threshold *= -gAnalyzer->GetXECPileupUnfoldingParameters()->GetDiffThreshold();
   }
   fPeakSearchThreshold = threshold;

   vPeak.clear();
   if (fPeakSearchThreshold < -10) {
      return;
   }

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   Int_t nPeak = fDiffWaveform->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                           TMath::Max(peakSearchWindow[0], fDiffWaveform->GetTimeAt(startPnt)),
                                           TMath::Min(peakSearchWindow[1], fDiffWaveform->GetTimeAt(fDiffWaveform->GetNPoints() - startPnt - 1)),
                                           threshold, 10 * MEG::nanosecond, -1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   const Double_t kThresholdWidth = 5 * MEG::nanosecond;
   for (Int_t i = 0; i < nPeak; i++) {
      if (vAmpl[i] != 0) {
         Double_t kFraction = threshold / vAmpl[i];
         Double_t pulseWidth = fDiffWaveform->PulseWidth(vAmpl[i], vPnt[i], 0, kFraction, -1);
         if (pulseWidth < kThresholdWidth) {
            continue; // remove spike
         }
         vPeak[vAmpl[i]] = vPnt[i];
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInDiff(const std::vector<Double_t>& peakSearchWindow,
                                                     std::map<Int_t, Double_t>& vPeak, Double_t threshold)
{
   // Peak search in given time region.
   // Result filled in vPeak<point, amplitude>.
   // Point (timing) ordered.

   fPeakSearchMethod = kSearchInDiff;

   const Int_t mva = gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetDifferentiation()->GetMovingAverage();
   const Int_t diffPnt = gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetDifferentiation()->GetNPoints();
   const Int_t startPnt = (diffPnt + mva) / 2 + 1;

   // Threshold scaled by noise RMS
   if (threshold > 0) {
      const Int_t nPnt = 50;
      Float_t rms = 0;
      rms = fDiffWaveform->CalculateRMS(fDiffWaveform->GetTimeAt(startPnt), fDiffWaveform->GetTimeAt(startPnt + nPnt));
      threshold = TMath::Sqrt(rms / nPnt);
      threshold *= -gAnalyzer->GetXECPileupUnfoldingParameters()->GetDiffThreshold();
   }
   fPeakSearchThreshold = threshold;

   vPeak.clear();
   if (fPeakSearchThreshold < -10) {
      return;
   }

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   Int_t nPeak = fDiffWaveform->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                           TMath::Max(peakSearchWindow[0], fDiffWaveform->GetTimeAt(startPnt)),
                                           TMath::Min(peakSearchWindow[1], fDiffWaveform->GetTimeAt(fDiffWaveform->GetNPoints() - startPnt - 1)),
                                           threshold, 10 * MEG::nanosecond, -1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   const Double_t kThresholdWidth = 5 * MEG::nanosecond;
   for (Int_t i = 0; i < nPeak; i++) {
      if (vAmpl[i] != 0) {
         Double_t kFraction = threshold / vAmpl[i];
         Double_t pulseWidth = fDiffWaveform->PulseWidth(vAmpl[i], vPnt[i], 0, kFraction, -1);
         if (pulseWidth < kThresholdWidth) {
            continue; // remove spike
         }
         vPeak[vPnt[i]] = vAmpl[i];
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::WaveformAnalysis()
{
   // Main pulse waveform is set as raw waveform - all the unfolded pulses waveform.
   // Pileup pulses waveform is set as fitted waveform.
   // Waveform analysis is conducted to obtain charge (Nsum).

   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1);
   Double_t refTime = 0 * MEG::nanosecond;
   TString algorithm = gAnalyzer->GetXECRunHeader()->GetRefTimeAlgorithmAt(gAnalyzer->GetEventHeader()->Getmask());

   Double_t tstart, tend;
   Double_t baseline, baseline_wf;
   Double_t vpeak;
   Double_t cfthr, cftime;
   Double_t charge, charge_wf;
   Int_t    peakbin;
   Double_t pktime;

   /* ------------- Main waveform analysis ----------------*/
   auto pulse = fvPulse[0];
   refTime = pulse->fT; // TODO: Backwards compatibility
   fMainWaveform->SetTime(fSumWaveform);
   fMainWaveform->SetAmplitude(pulse->fFitWaveform->GetAmplitude());
   fMainWaveform->Add(fResWaveform);
   Int_t startpnt = 0;
   Int_t endpnt   = fMainWaveform->FindPoint(fMainWaveform->GetTimeMax());
   fMainWaveform->MovingAverage(21, startpnt, endpnt, false, true);
   *fMainWaveform -= fvPulse[0]->fBase;

   // Baseline calculation
   tstart = TMath::Max(refTime + wfrh->GetBaselineStart(), fMainWaveform->GetTimeMin() + 15 * MEG::nanosecond);
   tend   = refTime + wfrh->GetBaselineEnd();
   baseline    = fMainWaveform->CalculateBaseline(tstart, tend);
   baseline_wf = fSumWaveform->CalculateBaseline(tstart, tend);

   // Peak extraction
   tstart = TMath::Max(refTime + wfrh->GetPeakSearchStart(), fMainWaveform->GetTimeMin() + 30 * MEG::nanosecond);
   tend   = TMath::Min(refTime + wfrh->GetPeakSearchEnd(),   fMainWaveform->GetTimeMax() - 30 * MEG::nanosecond);
   fMainWaveform->MinimumPeak(vpeak, peakbin, tstart, tend);
   pktime = fMainWaveform->GetTimeAt(peakbin);

   // Cftime calculation
   cfthr  = (vpeak - baseline) * wfrh->GetSumWFCFFraction();
   tstart = pktime - 100 * MEG::nanosecond;
   cftime = fMainWaveform->ConstantFraction(cfthr + baseline, vpeak * 0.8,
                                            tstart, pktime, -1);

   // Charge integration
   if (algorithm.Contains("PMTSUMWFCF") && cftime < fMainWaveform->GetTimeMax()) {
      refTime = cftime; // Update reference timing by cftime
   }
   tstart = TMath::Max(refTime + wfrh->GetChargeIntStart(), fMainWaveform->GetTimeMin() + 15 * MEG::nanosecond);
   tend   = refTime + wfrh->GetChargeIntEnd();
   charge    = fMainWaveform->ChargeIntegration(tstart, tend, baseline);
   charge_wf = fSumWaveform->ChargeIntegration(tstart, tend, baseline_wf);
   if (fNormCharge > 0) {
      pulse->fE   = -charge / fNormCharge;
      pulse->fEwf = -charge_wf / fNormCharge;
   }

   /* ------------- Pileup waveform analysis ----------------*/
   for (Int_t i = 1; i < static_cast<Int_t>(fvPulse.size()); i++) {
      auto pulse = fvPulse[i];
      refTime = pulse->fT;

      // Baseline calculation
      tstart = TMath::Max(refTime + wfrh->GetBaselineStart(), pulse->fFitWaveform->GetTimeMin() + 15 * MEG::nanosecond);
      tend   = refTime + wfrh->GetBaselineEnd();
      baseline = pulse->fFitWaveform->CalculateBaseline(tstart, tend);

      // Peak extraction
      tstart = TMath::Max(refTime + wfrh->GetPeakSearchStart(), pulse->fFitWaveform->GetTimeMin() + 30 * MEG::nanosecond);
      tend   = TMath::Min(refTime + wfrh->GetPeakSearchEnd(),   pulse->fFitWaveform->GetTimeMax() - 30 * MEG::nanosecond);
      pulse->fFitWaveform->MinimumPeak(vpeak, peakbin, tstart, tend);
      pktime = pulse->fFitWaveform->GetTimeAt(peakbin);

      // Cftime calculation
      cfthr = (vpeak - baseline) * wfrh->GetCFFraction();
      tstart = pktime - 100 * MEG::nanosecond;
      cftime = pulse->fFitWaveform->ConstantFraction(cfthr + baseline, vpeak * 0.8,
                                                     tstart, pktime, -1);

      // Charge integration
      if (algorithm.Contains("PMTSUMWFCF") && cftime < fSumWaveform->GetTimeMax()) {
         refTime = cftime; // Update reference timing by cftime
      }
      tstart = TMath::Max(refTime + wfrh->GetChargeIntStart(), pulse->fFitWaveform->GetTimeMin() + 15 * MEG::nanosecond);
      tend   = refTime + wfrh->GetChargeIntEnd();
      if (refTime > pulse->fFitWaveform->GetTimeMin()) {
         charge = pulse->fFitWaveform->ChargeIntegration(tstart, tend, baseline);
      } else {
         charge = -pulse->fE * fvTemplateWF[fIsSiPM ? 0 : 1]->fAmpl2Charge;
      }
      if (fNormCharge > 0) {
         pulse->fE   = -charge / fNormCharge;
         pulse->fEwf = pulse->fE;
      }
   } // end of pileup pulse loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::GetFitRegion(Double_t &fitstart, Double_t &fitend)
{
   // Get fit region based on pulse time.
   // Fit range is [fSumWaveform->GetTimeMin(), maxPulseTime + chargeIntEnd + fitMargin].

   if (!fvPulse.size()) {
      return;
   }

   Double_t maxpulsetime = fSumWaveform->GetTimeMin();
   for (auto pulse : fvPulse) {
      if (pulse->fT > maxpulsetime) {
         maxpulsetime = pulse->fT;
      }
   }

   Double_t fitMargin = gAnalyzer->GetXECPileupUnfoldingParameters()->GetFitMargin();
   fitstart = fSumWaveform->GetTimeMin();
   fitend   = TMath::Min(fSumWaveform->GetTimeMax(),
                         maxpulsetime + gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1)->GetChargeIntEnd() + fitMargin);
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::SetBaselineConstraint(const Bool_t addConstraint)
{
   // Set fit parameters of amplitude, timing, and baseline and their constraints
   // for pulses in baseline region.

   // Reset Baseline
   for (auto pulse : fvPulse) {
      pulse->fBase = 0;
      pulse->fBaseUncert = 0;
   }

   // Set Baseline
   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1);
   Double_t baseline = 0;
   baseline = fSumWaveform->CalculateBaseline(wfrh->GetBaselineStart(),
                                              wfrh->GetBaselineEnd());
   Double_t maxpeak = fSumWaveform->MaximumPeak(fSumWaveform->GetTimeMin(),
                                                fSumWaveform->GetTimeMax() - 50 * MEG::nanosecond);
   fvPulse[0]->fBase = baseline;
   fvPulse[0]->fBaseUncert = (maxpeak - baseline) / 5.;

   if (!addConstraint) {
      return;
   }

   // Add constraint to pileup before main gamma.
   for (auto pulse : fvPulse) {
      if (pulse->fFixParameter) {
         continue;
      }
      if (pulse->fT < fSumWaveform->GetTimeMin()) { // Invisible pulse
         Double_t maxE = 3. * (maxpeak - fSumWaveform->GetAmplitudeAt(0)); // Allow 3 * Y cut of the waveform
         pulse->fE = maxE / 2.;
         pulse->fEUncert = (maxE - pulse->fE) / 5.; // Range: [0, maxE]
      } else if (pulse->fT < wfrh->GetBaselineEnd()) {
         Double_t minpeak_bl = fSumWaveform->MinimumPeak(fSumWaveform->GetTimeMin(), wfrh->GetChargeIntStart());
         Double_t maxE = 3. * (maxpeak - minpeak_bl); // Allow 3 * minimum point of pre-baseline region
         pulse->fE = maxE / 2.;
         pulse->fEUncert = (maxE - pulse->fE) / 5.; // Range: [0, maxE]
      }
      pulse->fTUncert = TMath::Max(pulse->fTUncert, 2 * MEG::nanosecond);
   } // end of pulse loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::SetMainGammaConstraint()
{
   // Set fit parameters of amplitude, timing and their constraints
   // for pulses after baseline region.

   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1);
   Double_t maxpeak = fSumWaveform->MaximumPeak(fSumWaveform->GetTimeMin(),
                                                fSumWaveform->GetTimeMax() - 50 * MEG::nanosecond);

   for (auto pulse : fvPulse) {
      if (pulse->fFixParameter) {
         continue;
      }
      Double_t amplitude = fSumWaveform->MinimumPeak(pulse->fT - 20 * MEG::nanosecond,
                                                     pulse->fT + 20 * MEG::nanosecond);
      Double_t maxE = 1.5 * (maxpeak - amplitude);
      if (pulse->fT >= wfrh->GetBaselineEnd()) {
         pulse->fE = maxE / 2.;
         pulse->fEUncert = (maxE - pulse->fE) / 5.; // Range: [0, maxE]
      }
      if (pulse->fIsMain || pulse->fPulseIndex == 0 || pulse->fRefGamma >= kClusterGamma) {
         pulse->fTUncert = 5 * MEG::nanosecond;
      } else { // Not main gamma pulse.
         pulse->fTUncert = 5 * MEG::nanosecond;
         // Prevent pileup intrudes the coincidence window.
         if (TMath::Abs(pulse->fT - fRefTime) < 20 * MEG::nanosecond) {
            // To be removed.
            pulse->fE = 0;
            pulse->fEUncert = 0;
            pulse->fTUncert = 0 * MEG::nanosecond;
         }
         if (TMath::Abs(pulse->fT - fRefTime) - 20 * MEG::nanosecond < 5 * pulse->fTUncert) {
            pulse->fTUncert = TMath::Max((TMath::Abs(pulse->fT - fRefTime) - 20 * MEG::nanosecond) / 5.,
                                         2 * MEG::nanosecond);
         }
      } // end of if main
   } // end of pulse loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::RemoveInvalidPulse(const Double_t threshold, const Bool_t kPrint)
{
   // Remove invalid pulses. Criteria are
   //   - Invalid flag
   //   - Not main && amplitude < threshold && seed from no reference or diff
   //   - Pulse timing after time window

   Int_t ipulse = 0;
   Int_t jpulse = 0;
   Int_t npulse = static_cast<Int_t>(fvPulse.size());
   if (npulse <= 1) {
      return;
   }

   while (1) {
      if (fvPulse[ipulse]->fIsInvalid ||
          (!fvPulse[ipulse]->fIsMain && fvPulse[ipulse]->fE < threshold && fvPulse.size() > 1 && fvPulse[ipulse]->fRefGamma < kClusterGamma) ||
          fvPulse[ipulse]->fT > fSumWaveform->GetTimeMax()) {
         if (kPrint) {
            std::cout << ipulse << "th pulse removed. ref: " << fvPulse[ipulse]->fRefGamma
                      << " E: " << fvPulse[ipulse]->fE << std::endl;
         }

         fvPulse.erase(fvPulse.begin() + ipulse);
      } else {
         ipulse++;
      }
      jpulse++;
      if (jpulse >= npulse) {
         break;
      }
   }

}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::MergeCoincidentPulse()
{
   // Merge coincident pulses.

   for (Int_t iPulse = 0; iPulse < (Int_t)fvPulse.size(); iPulse++) {
      while (1) {
         Bool_t fCoincidentPulseFound = false;
         for (Int_t jPulse = iPulse + 1; jPulse < (Int_t)fvPulse.size(); jPulse++) {
            if (TMath::Abs(fvPulse[iPulse]->fT - fvPulse[jPulse]->fT) < gAnalyzer->GetXECPileupUnfoldingParameters()->GetCoincidenceWindow()) {
               // For pedestal analysis
               if ((fvPulse[iPulse]->fIsMain && fvPulse[iPulse]->fFixParameter) ||
                   (fvPulse[jPulse]->fIsMain && fvPulse[jPulse]->fFixParameter)) {
                  continue;
               }
               // If both come from clustergamma
               if (fvPulse[iPulse]->fRefGamma >= kClusterGamma &&
                   fvPulse[jPulse]->fRefGamma >= kClusterGamma) {
                  continue;
               }
               // if coincident pulse found
               if ((fvPulse[iPulse]->fRefGamma != kNoReference &&
                    fvPulse[jPulse]->fRefGamma != kNoReference &&
                    fvPulse[jPulse]->fE > fvPulse[iPulse]->fE) ||
                   (fvPulse[jPulse]->fRefGamma != kNoReference &&
                    fvPulse[iPulse]->fRefGamma == kNoReference)) {
                  std::iter_swap(fvPulse.begin() + iPulse, fvPulse.begin() + jPulse);
               }
               fvPulse[iPulse]->fE += fvPulse[jPulse]->fE;
               fvPulse.erase(fvPulse.begin() + jPulse);
               // std::cout << "coincident pulse found" << std::endl;
               fCoincidentPulseFound = true;
               break;
            }
         } // end of jPulse loop
         if (!fCoincidentPulseFound) {
            break;
         }
      } // end of infinite loop
   } // end of iPulse loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::CheckConversion()
{
   // Check converged or not using chi2.

   fFCN = GetIntegratedChi2();
   if (fFCN > gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2Threshold()) {
      fFitStatus = kNotConverged;
   } else {
      fFitStatus = kConverged;
   }
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::SumWF::GetIntegratedChi2()
{
   // Integrate chi2 waveform out.

   Double_t chi2 = 1e10;
   Double_t tstart = fChi2Waveform->GetTimeMin();
   Double_t tend   = gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1)->GetChargeIntEnd();
   Int_t npoint = fChi2Waveform->FindPoint(tend) - fChi2Waveform->FindPoint(tstart);
   if (npoint <= 0) {
      return chi2;
   }

   chi2 = fChi2Waveform->ChargeIntegration(tstart, tend, 0) / npoint;
   if (gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2Switch() > 0) {
      chi2 *= 1. / fTemplateWF->fSamplingInterval * kDRSInputImpedance;
   }
   return chi2;
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::SumWF::GetResidualPulseHeight()
{
   // Calculate pulse height of residual waveform.

   Double_t maxpeak = fResWaveform->MaximumPeak(fResWaveform->GetTimeMin(),
                                                fResWaveform->GetTimeMax() - 50 * MEG::nanosecond);
   Double_t minpeak = fResWaveform->MinimumPeak(fResWaveform->GetTimeMin(),
                                                gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1)->GetChargeIntEnd());

   return maxpeak - minpeak; // maximum E value
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::SumWF::FindResidualPulse(Double_t& time, Double_t& peak, const Double_t threshold, const Bool_t baselinesearch)
{
   // Find a residual pulse based on chi2 waveform and estimate the amplitude from the residual waveform.

   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1);
   Double_t fitMargin = gAnalyzer->GetXECPileupUnfoldingParameters()->GetFitMargin();
   Double_t starttime = fResWaveform->GetTimeMin();
   Double_t endtime   = TMath::Max(wfrh->GetBaselineEnd(), fResWaveform->GetTimeMin());
   if (!baselinesearch) {
      starttime = wfrh->GetChargeIntStart() + 50 * MEG::nanosecond;
      endtime = TMath::Min(wfrh->GetChargeIntEnd() + fitMargin,
                           fChi2Waveform->GetTimeMax() - 50 * MEG::nanosecond);
   }
   if (endtime <= starttime) {
      return false;
   }

   // Estimate timing with chi2 waveform
   Double_t chi2peak;
   Int_t pkpoint;
   fChi2Waveform->MaximumPeak(chi2peak, pkpoint, fChi2Waveform->GetTimeMin(), endtime);
   chi2peak = fResWaveform->GetAmplitudeAt(pkpoint);

   // Estimate amplitude assuming maximum point of residual waveform is baseline.
   Double_t minpeak = fResWaveform->MaximumPeak(fResWaveform->GetTimeMin(), endtime);
   Double_t maxE = minpeak - chi2peak; // Minumum peak of residual waveform - peak at chi2 peak point 
   peak = maxE;
   time = fResWaveform->GetTimeAt(pkpoint);
   Bool_t closeToPulseTiming = false;
   for (auto pulse : fvPulse) {
      Double_t timediff = time - pulse->fT;
      if (TMath::Abs(timediff) < 30 * MEG::nanosecond) {
         closeToPulseTiming = true;
      }
   }
   // Found pulse is valid only when the amplitude is large and far from the existing pulses.
   if (maxE > threshold && !closeToPulseTiming) {
      return true;
   }
   return false;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PulseTimeBasedInvalidation()
{
   // Flag invalid for a pulse whose timing is after time window or differs from that of existing pulses within coincidence window.

   std::vector<Double_t> vTime;
   for (auto pulse : fvPulse) {
      if (pulse->fIsMain) {
         vTime.push_back(pulse->fT);
         continue;
      }
      if (pulse->fT > fSumWaveform->GetTimeMax()) {
         pulse->fIsInvalid = kTRUE;
         continue;
      }
      for (auto t : vTime) {
         if (TMath::Abs(pulse->fT - t) < gAnalyzer->GetXECPileupUnfoldingParameters()->GetClusterCoincWindow()) {
            pulse->fIsInvalid = kTRUE;
         }
      }
      if (pulse->fIsInvalid) continue;

      vTime.push_back(pulse->fT);
   }
   vTime.clear();
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::SumWF::GetExpAmplAt(Int_t iPnt, Double_t* par)
{
   // Get expected amplitude at iPnt.
   // par[0] : Scale of WF. [1] : Timing of WF. [2] : Baseline of WF.

   Int_t nPntShift = static_cast<Int_t>(TMath::Abs(par[1]) / fSumWaveform->GetBinSize());
   Double_t ratio = (TMath::Abs(par[1]) - nPntShift * fSumWaveform->GetBinSize()) / fSumWaveform->GetBinSize();
   Int_t jPnt = iPnt - ((par[1] > 0) ? nPntShift : -nPntShift);
   Int_t kPnt = jPnt - ((par[1] > 0) ? 1 : -1);
   Int_t dT0Pnt = fSumWaveform->FindPoint(0) - fTemplateWF->fT0Pnt;
   jPnt -= dT0Pnt;
   kPnt -= dT0Pnt;
   jPnt = TMath::Max(jPnt, 0);
   kPnt = TMath::Max(kPnt, 0);
   jPnt = TMath::Min(jPnt, (Int_t)fTemplateWF->fTemplateMean.size() - 1);
   kPnt = TMath::Min(kPnt, (Int_t)fTemplateWF->fTemplateMean.size() - 1);

   Double_t mean = fTemplateWF->fTemplateMean[jPnt] * (1 - ratio) + fTemplateWF->fTemplateMean[kPnt] * ratio;
   mean *= par[0];
   mean += par[2];
   return mean;
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::SumWF::GetExpUncertAt(Int_t iPnt, Double_t* par)
{
   // Get expected uncertainty at iPnt.
   // par[0] : Scale of WF. [1] : Timing of WF. [2] : Baseline of WF.

   Double_t rms = -1.;

   switch (gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2Switch()) {
   case 0:
      rms = 4000;
      break;
   case 1:
   default:
      Int_t nPntShift = static_cast<Int_t>(TMath::Abs(par[1]) / fSumWaveform->GetBinSize());
      Double_t ratio = (TMath::Abs(par[1]) - nPntShift * fSumWaveform->GetBinSize()) / fSumWaveform->GetBinSize();
      Int_t jPnt = iPnt - ((par[1] > 0) ? nPntShift : -nPntShift);
      Int_t kPnt = jPnt - ((par[1] > 0) ? 1 : -1);
      Int_t dT0Pnt = fSumWaveform->FindPoint(0) - fTemplateWF->fT0Pnt;
      jPnt -= dT0Pnt;
      kPnt -= dT0Pnt;
      jPnt = TMath::Max(jPnt, 0);
      kPnt = TMath::Max(kPnt, 0);
      jPnt = TMath::Min(jPnt, (Int_t)fTemplateWF->fTemplateMean.size() - 1);
      kPnt = TMath::Min(kPnt, (Int_t)fTemplateWF->fTemplateMean.size() - 1);

      rms = fTemplateWF->fTemplateUncert[jPnt] * (1 - ratio) + fTemplateWF->fTemplateUncert[kPnt] * ratio;
      rms *= par[0];
      break;
   }
   return rms;
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::SumWF::GetChi2At(Int_t iPnt, Double_t* par)
{
   // Get "chi2" = res^2 / rms^2 at iPnt.
   // Refer to FCN() for definition of par.

   if (!fSumWaveform || fSumWaveform->GetNPoints() == 0) {
      return 1e10; // invalid chi2
   }

   Double_t ampl = fSumWaveform->GetAmplitudeAt(iPnt);
   Double_t mean = 0;
   Double_t rms = 0;
   for (Int_t iGamma = 0; iGamma < par[4]; iGamma++) {
      mean += GetExpAmplAt(iPnt, par + 5 + 3 * iGamma);
      rms = TMath::Sqrt(TMath::Power(rms, 2) + TMath::Power(GetExpUncertAt(iPnt, par + 5 + 3 * iGamma), 2));
   }
   rms = TMath::Max(rms, 1e-12);
   return (ampl - mean) * (ampl - mean) / rms / rms;
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::SumWF::GetResAt(Int_t iPnt, Double_t* par)
{
   // Get residual between observed and expected amplitudes.
   // Refer to FCN() for definition of par.

   Double_t ampl = fSumWaveform->GetAmplitudeAt(iPnt);
   Double_t mean = 0;
   for (Int_t iGamma = 0; iGamma < par[4]; iGamma++) {
      mean += GetExpAmplAt(iPnt, par + 5 + 3 * iGamma);
   }
   return ampl - mean;
}

//______________________________________________________________________________
Float_t MEGTXECPileupUnfolding::SumWF::GetEnePMWeight(Int_t iPM)
{
   // Get EnePMWeight.

   if (!gAnalyzer->GetXECEnePMWeightResultSize()) {
      //Report(R_WARNING, "No EnePMWeight results. Weight is 0.");
      return 0.;
   }

   MEGXECPMRunHeader *pmrh = gAnalyzer->GetXECPMRunHeaderAt(iPM);
   if (pmrh->GetIsBad()) {
      //Report(R_WARNING, "Channel %d is bad. Skip it!", iPM);
      return 0.;
   }
   if (!pmrh->GetGain() || !pmrh->GetWDGain() || !pmrh->GetQE() || !pmrh->GetCE() || !pmrh->GetCTAP()) {
      Report(R_WARNING, "Gain*WDGain*CTAP*QE*CE is 0 for PM %d. Weight of %d is set to be 0.", iPM, iPM);
      return 0.;
   }

   // EnePMWeight assumes nGamma = 1
   Float_t weight = gAnalyzer->GetXECEnePMWeightResultAt(iPM)->GetweightAt(0)
      / pmrh->GetGain() / pmrh->GetWDGain() / pmrh->GetQE() / pmrh->GetCE() / pmrh->GetCTAP() / eplus;

   return weight;
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::SumWF::GetConstantFractionTime()
{
   // Get constant fraction time.

   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(fIsSiPM ? 0 : 1);

   // Peak search and baseline calculation
   Double_t pkampl;
   Int_t    pkpoint;
   fSumWaveform->MinimumPeak(pkampl, pkpoint, wfrh->GetChargeIntStart(), wfrh->GetChargeIntEnd());
   Double_t pktime   = fSumWaveform->GetTimeAt(pkpoint);
   Double_t baseline = fSumWaveform->CalculateBaseline(wfrh->GetBaselineStart(), wfrh->GetBaselineEnd());

   // Cftime calculation
   Double_t cfamplitude = (pkampl - baseline) * wfrh->GetSumWFCFFraction() + baseline;
   Double_t cftime = fSumWaveform->ConstantFraction(cfamplitude, pkampl * 0.9,
                                                    pktime - 80 * MEG::nanosecond, pktime + 20 * MEG::nanosecond,
                                                    -1, "CUBIC");
   if (TMath::Abs(cftime - pktime) > 100 * MEG::nanosecond) {
      cftime = MEGWaveform::kInvalidTime;
   }

   return cftime;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::Deconvolute(MEGWaveform *wfin, const Int_t method, Double_t pulseWidth, const Bool_t kPrint)
{
   if (!wfin || !wfin->GetNPoints()) {
      Report(R_WARNING, "Input waveform is invalid. Skip doconvlution.");
      return;
   }

   if (!fTemplateWF->fTemplateFit) {
      Report(R_WARNING, "Failed to prepare TemplateFit. Skip doconvlution.");
      return;
   }

   if (!fDeconvWF && PrepareDeconvWF(wfin, method, pulseWidth) != 1) {
      Report(R_WARNING, "Failed to prepare DeconvWF. Skip doconvlution.");
      return;
   }
   fDeconvWF->fRawWaveform = wfin;
   fDeconvWF->fDeconvWaveform->SetNPoints(wfin->GetNPoints());

   MEGWaveform* wf = new MEGWaveform(kDRSBins);
   wfin->Sampling(wfin->GetNPoints(), wfin->GetTimeMin(), wfin->GetBinSize(), wf, "precise");

   switch (method) {
   case kFFTConv:
      wf->FFTConvolution(fDeconvWF->fFreqRes, fDeconvWF->fDeconvWaveform);
      break;
   case kFIRConv:
   default:
      wf->FIR(wfin->GetNPoints(), fDeconvWF->fKernel->GetAmplitude(), fDeconvWF->fDeconvWaveform);
      break;
   }

   if (kPrint) {
      TCanvas *canvas;
      if (!(canvas = (TCanvas*)gROOT->FindObject("cXECSumWFPLUF_Deconv"))) {
         canvas = new TCanvas("cXECSumWFPLUF_Deconv", "cXECSumWFPLUF_Deconv", 1200, 400);
         canvas->Divide(2);
      }
      canvas->cd(fIndex + 1);
      wfin->SetLineColor(kBlack);
      wfin->Draw();
      fDeconvWF->fDeconvWaveform->SetLineColor(kBlue);
      //fDeconvWF->GetYaxis()->SetRangeUser(-1, 0);
      fDeconvWF->fDeconvWaveform->Draw("same");
      fDeconvWF->fKernel->SetLineColor(kRed);
      fDeconvWF->fKernel->Draw("same");
      canvas->Update();
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::DeconvPeakSearch()
{
   if (!fDeconvWF || fDeconvWF->fDeconvWaveform->GetNPoints() == 0) {
      return;
   }
   fDeconvWF->fvPeak.clear();

   /* ------------- Peak Search----------------*/
   const Int_t kMaxNPulse = 10;
   Int_t pkpoint[kMaxNPulse];
   Double_t pkampl[kMaxNPulse];
   Int_t nPulse = fDeconvWF->fDeconvWaveform->PeakSearch(pkampl, pkpoint, kMaxNPulse,
                                                         fDeconvWF->fDeconvWaveform->GetTimeMin() + 10 * MEG::nanosecond,
                                                         fDeconvWF->fDeconvWaveform->GetTimeMax() - 10 * MEG::nanosecond,
                                                         -50 * MEG::millivolt,
                                                         10 * MEG::nanosecond,
                                                         -1);

   Double_t norm = 1e-12;
   for (Int_t iPulse = 0; iPulse < nPulse; iPulse++) {
      norm = TMath::Max(-pkampl[iPulse], norm);
   }
   for (Int_t iPulse = 0; iPulse < nPulse; iPulse++) {
      fDeconvWF->fvPeak.push_back(std::make_pair(-pkampl[iPulse] / norm,
                                                 fDeconvWF->fDeconvWaveform->GetTimeAt(pkpoint[iPulse])));
   }
   std::sort(fDeconvWF->fvPeak.begin(), fDeconvWF->fvPeak.end(), [](std::pair<Double_t, Double_t> lh, std::pair<Double_t, Double_t> rh) {
      return lh.first > rh.first;
   });
}

//______________________________________________________________________________
Int_t MEGTXECPileupUnfolding::SumWF::PrepareDeconvWF(MEGWaveform* wfin, const Int_t method, Double_t pulseWidth)
{
   if (!fTemplateWF->fTemplateFit) {
      return -1;
   }
   for (auto wf : fvDeconvWF) {
      if (wf->fIndex == fIndex) {
         fDeconvWF = wf;
      }
   }
   if (!fDeconvWF) {
      fDeconvWF = new DeconvWF(fIndex);
      fDeconvWF->fDeconvWaveform = new MEGXECDRSWaveform();
      fDeconvWF->fKernel = new MEGWaveform(kDRSBins, wfin->GetBinSize());
      fvDeconvWF.push_back(fDeconvWF);

      fDeconvWF->fPulseWidth = pulseWidth;
      Double_t pktime = fTemplateWF->fTemplateFit->fPeakTime;
      Double_t t0 = pktime - pulseWidth * 0.5;

      MEGWaveform *wfTemplate = new MEGWaveform();
      fTemplateWF->fTemplateFit->fTemplateWaveform->Sampling(kDRSBins, t0, wfin->GetBinSize(),
                                                             wfTemplate, "precise");
      *wfTemplate /= fTemplateWF->fTemplateFit->fPeakToPeak;

      MEGWaveform *wftmp = new MEGWaveform(kDRSBins, wfTemplate->GetBinSize(), t0);
      Int_t nPnt = static_cast<Int_t>(fDeconvWF->fPulseWidth / wfTemplate->GetBinSize());
      if (nPnt > wfTemplate->GetNPoints()) {
         Report(R_WARNING,
                "The pulse width for deconvolution is too wide. It must be shorter than %.1f ns. Automatically set to the maximum.",
                wfTemplate->GetBinSize() * wfTemplate->GetNPoints() * nanosecond);
         nPnt = wfTemplate->GetNPoints();
         fDeconvWF->fPulseWidth = wfTemplate->GetBinSize() * wfTemplate->GetNPoints();
      }
      for (Int_t iPnt = 0; iPnt < nPnt; iPnt++) {
         wftmp->SetAmplitudeAt(iPnt, wfTemplate->GetAmplitudeAt(iPnt));
      }
      MEGWaveform::BlackmanWindow(nPnt, wftmp->GetAmplitude());
      MEGWaveform::FormFilterKernel(wfTemplate, wftmp, fDeconvWF->fKernel, kDRSBins);
      if (method == kFFTConv) {
         fDeconvWF->fFreqRes = new MEGFrequencyResponse();
         fDeconvWF->fFreqRes->FormFrequencyResponse(fDeconvWF->fKernel->GetNPoints(), fDeconvWF->fKernel->GetAmplitude(), 2);
      }
      delete wftmp;
      delete wfTemplate;
   }

   if (fDeconvWF) {
      return 1;
   } else {
      return -1;
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInRes(const std::vector<Double_t>& peakSearchWindow,
                                                    std::map<Double_t, Int_t, std::less<Double_t>>& vPeak, Double_t threshold)
{
   // Peak search in given time region.
   // Result filled in vPeak<amplitude, point>.
   // Amplitude ordered.

   fPeakSearchMethod = kSearchInRes;

   const Int_t startPnt = 0;
   if (threshold > 0) {
      const Int_t nPnt = 50;
      Float_t rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(fResWaveform->GetAmplitudeAt(iPnt), 2);
      }
      threshold = TMath::Sqrt(rms / nPnt);

      rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(fResWaveform->GetAmplitudeAt(fResWaveform->GetNPoints() - iPnt - 1), 2);
      }
      threshold = TMath::Min(threshold, TMath::Sqrt(rms / nPnt));
      threshold *= -gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetResidual()->GetPeakSearchThreshold();
   }
   fPeakSearchThreshold = threshold;

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   MEGXECDRSWaveform* wf = new MEGXECDRSWaveform(*fResWaveform);
   wf->MovingAverage(gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetResidual()->GetMovingAverage());
   Int_t nPeak = wf->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                TMath::Max(peakSearchWindow[0], fResWaveform->GetTimeAt(2)),
                                TMath::Min(peakSearchWindow[1], fResWaveform->GetTimeAt(fResWaveform->GetNPoints() - 3)),
                                threshold, 50 * MEG::nanosecond, -1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   vPeak.clear();
   for (Int_t i = 0; i < nPeak; i++) {
      vPeak[vAmpl[i]] = vPnt[i];
   }

   delete wf;

   return;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInRes(const std::vector<Double_t>& peakSearchWindow,
                                                    std::map<Int_t, Double_t>& vPeak, Double_t threshold)
{
   // Peak search in given time region.
   // Result filled in vPeak<point, amplitude>.
   // Point (timing) ordered.

   fPeakSearchMethod = kSearchInRes;

   const Int_t startPnt = 0;
   if (threshold > 0) {
      const Int_t nPnt = 50;
      Float_t rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(fResWaveform->GetAmplitudeAt(iPnt), 2);
      }
      threshold = TMath::Sqrt(rms / nPnt);

      rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(fResWaveform->GetAmplitudeAt(fResWaveform->GetNPoints() - iPnt - 1), 2);
      }
      threshold = TMath::Min(threshold, TMath::Sqrt(rms / nPnt));
      threshold *= -gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetResidual()->GetPeakSearchThreshold();
   }
   fPeakSearchThreshold = threshold;

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   MEGXECDRSWaveform* wf = new MEGXECDRSWaveform(*fResWaveform);
   wf->MovingAverage(gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetResidual()->GetMovingAverage());
   Int_t nPeak = wf->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                TMath::Max(peakSearchWindow[0], fResWaveform->GetTimeAt(2)),
                                TMath::Min(peakSearchWindow[1], fResWaveform->GetTimeAt(fResWaveform->GetNPoints() - 3)),
                                threshold, 50 * MEG::nanosecond, -1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   vPeak.clear();
   for (Int_t i = 0; i < nPeak; i++) {
      vPeak[vPnt[i]] = vAmpl[i];
   }

   delete wf;

   return;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInMVA(const std::vector<Double_t>& peakSearchWindow,
                                                    std::map<Double_t, Int_t, std::less<Double_t>>& vPeak, Double_t threshold)
{
   // Peak search in given time region.
   // Result filled in vPeak<amplitude, point>.
   // Amplitude ordered.
   // This method is used in ClusterGamma analysis.

   fPeakSearchMethod = kSearchInMVA;

   const Int_t startPnt = 0;
   
   if (threshold > 0) {
      const Int_t nPnt = 50;
      Float_t rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(TMath::Min(1e4, TMath::Abs(fMVAWaveform->GetAmplitudeAt(iPnt))), 2);
      }
      threshold = TMath::Sqrt(rms / nPnt);

      rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(TMath::Min(1e4, TMath::Abs(fMVAWaveform->GetAmplitudeAt(fMVAWaveform->GetNPoints() - iPnt - 1))), 2);
      }
      threshold = TMath::Min(threshold, TMath::Sqrt(rms / nPnt));
      threshold *= -gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetMovingAverage()->GetPeakSearchThreshold();
   }
   fPeakSearchThreshold = threshold;

   vPeak.clear();
   if (fPeakSearchThreshold < -10) {
      return;
   }

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   Int_t nPeak = fMVAWaveform->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                          TMath::Max(peakSearchWindow[0], fMVAWaveform->GetTimeAt(startPnt)),
                                          TMath::Min(peakSearchWindow[1], fMVAWaveform->GetTimeAt(fMVAWaveform->GetNPoints() - startPnt - 1)),
                                          threshold, 30 * MEG::nanosecond, -1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   vPeak.clear();
   const Double_t kThresholdWidth = 30 * MEG::nanosecond;
   for (Int_t i = 0; i < nPeak; i++) {
      Double_t kFraction = threshold / vAmpl[i];
      Double_t pulseWidth = fMVAWaveform->PulseWidth(vAmpl[i], vPnt[i], 0, kFraction, -1);
      if (pulseWidth < kThresholdWidth && vAmpl[i] > threshold * 1.2) {
         continue; // remove spike
      }
      vPeak[vAmpl[i]] = vPnt[i];
   }
   return;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SumWF::PeakSearchInMVA(const std::vector<Double_t>& peakSearchWindow,
                                                    std::map<Int_t, Double_t>& vPeak, Double_t threshold)
{
   // Peak search in given time region.
   // Result filled in vPeak<point, amplitude>.
   // Point (timing) ordered.
   // This method is used in ClusterGamma analysis.

   fPeakSearchMethod = kSearchInMVA;

   const Int_t startPnt = 0;

   if (threshold > 0) {
      const Int_t nPnt = 50;
      Float_t rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(TMath::Min(1e4, TMath::Abs(fMVAWaveform->GetAmplitudeAt(iPnt))), 2);
      }
      threshold = TMath::Sqrt(rms / nPnt);

      rms = 0;
      for (Int_t iPnt = startPnt; iPnt < startPnt + nPnt; iPnt++) {
         rms += TMath::Power(TMath::Min(1e4, TMath::Abs(fMVAWaveform->GetAmplitudeAt(fMVAWaveform->GetNPoints() - iPnt - 1))), 2);
      }
      threshold = TMath::Min(threshold, TMath::Sqrt(rms / nPnt));
      threshold *= -gAnalyzer->GetXECPileupUnfoldingTask()->GetSP()->GetMovingAverage()->GetPeakSearchThreshold();
   }
   fPeakSearchThreshold = threshold;

   vPeak.clear();
   if (fPeakSearchThreshold < -10) {
      return;
   }

   const Int_t kPeakMAX = 1000;
   std::vector<Double_t> vAmpl(kPeakMAX, 0);
   std::vector<Int_t> vPnt(kPeakMAX, 0);
   Int_t nPeak = fMVAWaveform->PeakSearch(&vAmpl[0], &vPnt[0], kPeakMAX,
                                          TMath::Max(peakSearchWindow[0], fMVAWaveform->GetTimeAt(startPnt)),
                                          TMath::Min(peakSearchWindow[1], fMVAWaveform->GetTimeAt(fMVAWaveform->GetNPoints() - startPnt - 1)),
                                          threshold, 30 * MEG::nanosecond, -1);
   nPeak = TMath::Min(nPeak, kPeakMAX); // this must be called since nPeak can be larger than kPeakMAX

   vPeak.clear();
   const Double_t kThresholdWidth = 30 * MEG::nanosecond;
   for (Int_t i = 0; i < nPeak; i++) {
      Double_t kFraction = threshold / vAmpl[i];
      Double_t pulseWidth = fMVAWaveform->PulseWidth(vAmpl[i], vPnt[i], 0, kFraction, -1);
      if (pulseWidth < kThresholdWidth && vAmpl[i] > threshold * 1.2) {
         continue; // remove spike
      }
      vPeak[vPnt[i]] = vAmpl[i];
   }

   return;
}

//__________________________________________________________________________________
void MEGTXECPileupUnfolding::FCN(Int_t & /*npar*/, Double_t * /*gin*/, Double_t &f, Double_t *par, Int_t /*iflag*/)
{
   // FCN function to fit WF.
   // par[0] : switch to choose vWF.
   // par[1] : Index of Fitted WF.
   // par[2] : LL of Fit range.
   // par[3] : UL of Fit range.
   // par[4] : Number of Gamma.
   // par[5+3*nGamma] : Scale of WF.
   // par[6+3*nGamma] : Timing of WF.
   // par[7+3*nGamma] : Baseline of WF.

   f = 0.;
   auto wf = (par[0] == static_cast<Double_t>(SumWF::kTotalSumWF) ? fvTotalSumWF[par[1]] : fvClusterSumWF[par[1]]);
   for (Int_t iPnt = par[2]; iPnt <= par[3]; iPnt++) {
      f += wf->GetChi2At(iPnt, par) / (par[3] - par[2] + 1 - par[4] * 2);
   }
   return;
}

//__________________________________________________________________________________
void MEGTXECPileupUnfolding::SimulFCN(Int_t & /*npar*/, Double_t * /*gin*/, Double_t &f, Double_t *par, Int_t /*iflag*/)
{
   // FCN function to simultaneous fit WF.
   // par[0] : LL of Fit range.
   // par[1] : UL of Fit range.
   // par[2] : Number of pulses.
   // par[3+6*nGamma] : Scale of MPPC WF.
   // par[4+6*nGamma] : Time difference from PMT timing (par[7+6*nGamma]).
   // par[5+6*nGamma] : Baseline of MPPC WF.
   // par[6+6*nGamma] : Scale of PMT WF.
   // par[7+6*nGamma] : Timing of PMT WF.
   // par[8+6*nGamma] : Baseline of PMT WF.

   f = 0.;

   Int_t nPar = 5 + par[2] * 3;
   std::vector<Double_t> mppcpar(nPar, 0.);
   std::vector<Double_t> pmtpar(nPar, 0.);
   pmtpar[1] = TemplateWF::kPMT;
   for (Int_t iPar = 2; iPar < 5; iPar++) {
      mppcpar[iPar] = par[iPar - 2];
      pmtpar[iPar]  = par[iPar - 2];
   }
   for (Int_t iGamma = 0; iGamma < par[2]; iGamma++) {
      mppcpar[5 + iGamma * 3 + 0] = par[3 + iGamma * 6 + 0];
      mppcpar[5 + iGamma * 3 + 1] = par[3 + iGamma * 6 + 1] + par[3 + iGamma * 6 + 4];
      mppcpar[5 + iGamma * 3 + 2] = par[3 + iGamma * 6 + 2];
      pmtpar[5 + iGamma * 3 + 0]  = par[3 + iGamma * 6 + 3];
      pmtpar[5 + iGamma * 3 + 1]  = par[3 + iGamma * 6 + 4];
      pmtpar[5 + iGamma * 3 + 2]  = par[3 + iGamma * 6 + 5];
   }
   for (Int_t iPnt = par[0]; iPnt <= par[1]; iPnt++) {
      f += fvTotalSumWF[TemplateWF::kSiPM]->GetChi2At(iPnt, &mppcpar[0]);
      f += fvTotalSumWF[TemplateWF::kPMT] ->GetChi2At(iPnt, &pmtpar[0] );
   }

   f /= static_cast<Double_t>(par[1] - par[0] + 1);
   mppcpar.clear();
   pmtpar.clear();
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::UpdateParametersFromSP()
{
   // Fill steering parameters if SP value is valid.

   auto pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();

   Short_t shortVal;
   Int_t intVal;
   Float_t floatVal;
   Double_t doubleVal;

   if ((intVal = GetSP()->GetReadTemplate()->GetTemplateID()) > -0.99) {
      pParameters->SetTemplateId(intVal);
   }
   if ((floatVal = GetSP()->GetFitMargin()) > -0.99) {
      pParameters->SetFitMargin(floatVal);
   }
   if ((floatVal = GetSP()->GetCoincidenceWindow()) > -0.99) {
      pParameters->SetCoincidenceWindow(floatVal);
   }
   if ((floatVal = GetSP()->GetClusterCoincWindow()) > -0.99) {
      pParameters->SetClusterCoincWindow(floatVal);
   }
   if ((shortVal = GetSP()->GetSimultaneousFit()->GetActive()) > -0.99) {
      pParameters->SetSimultaneousFitFlag(static_cast<Bool_t>(shortVal));
   }
   if ((doubleVal = GetSP()->GetSimultaneousFit()->GetFixedMPPCMinusPMT()) > -0.99) {
      pParameters->SetMPPCMinusPMT(doubleVal);
   }
   if ((floatVal = GetSP()->GetNinner2Threshold()) > -0.99) {
      pParameters->SetNinner2Threshold(floatVal);
   }
   if ((floatVal = GetSP()->GetNpmt2Threshold()) > -0.99) {
      pParameters->SetNpmt2Threshold(floatVal);
   }
   if ((floatVal = GetSP()->GetChi2Threshold()) > -0.99) {
      pParameters->SetChi2Threshold(floatVal);
   }
   if ((intVal = GetSP()->GetReferenceSwitch()) > -0.99) {
      pParameters->SetReferenceSwitch(intVal);
   }
   if ((shortVal = GetSP()->GetChi2Switch()) > -0.99) {
      pParameters->SetChi2Switch(shortVal);
   }
   if ((floatVal = GetSP()->GetDifferentiation()->GetPeakSearchThreshold()) > -9.9) {
      pParameters->SetDiffThreshold(floatVal);
   }
   if ((intVal = GetSP()->GetClusterAnalysis()->GetMethod()) > -0.99) {
      pParameters->SetClusterAnalysisMethod(intVal);
   }
   if ((floatVal = GetSP()->GetFADCWaveformAnalysis()->GetQpmtThreshold()) > -0.99) {
      pParameters->SetFADCQpmtThreshold(floatVal);
   }

   fNinner2Threshold = pParameters->GetNinner2Threshold();
   fNpmt2Threshold   = pParameters->GetNpmt2Threshold();

   if (fPrint) {
      pParameters->Print("");
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::PrepareTemplate()
{
   // Prepare template waveforms.

   /* ------------- Read template----------------*/
   const Int_t kMaxReadTemplate = 6; // should be increased if more
   TemplateWF* wf;
   TString fileName = Form("%s/XECWFTemplateUF_%05d.root",
                           GetSP()->GetReadTemplate()->GetTemplateDirectory().Data(),
                           gAnalyzer->GetXECPileupUnfoldingParameters()->GetTemplateId());

   if (fileName == fTemplateFileName) { // same template
      return;
   }

   fTemplateFileName = fileName;
   if (fInputFileTemplate) {
      fInputFileTemplate->Close();
      delete fInputFileTemplate;
      fInputFileTemplate = 0;
   }
   for (auto sumwf : fvTemplateWF) {
      sumwf->Clear("D");
   }
   fvTemplateWF.clear();

   TFile* fin = new TFile(fileName, "READ");
   if (!fin) {
      Report(R_WARNING, "No template file is found.");
      return;
   }

   TParameter<Double_t>* par_samplingInterval = (TParameter<Double_t>*)fin->Get("samplingInterval");

   std::string name, title;
   for (Int_t i = 0; i < kMaxReadTemplate; i++) {
      name = Form("XECSumWFTemplate_%d", i);
      if (!fin->Get(name.c_str())) {
         continue;
      }

      title = ((TH2D*)fin->Get(name.c_str()))->GetTitle();
      TString type = "NONE";
      if (title.find("Type: ") != std::string::npos) {
         type = title.substr(title.find("Type: ") + 6, title.find(".", title.find("Type: ")) - title.find("Type: ") - 6);
      } else {
         continue;
      }
      if (!(type.Contains(fvTemplateType[TemplateWF::kSiPM])
            || type.Contains(fvTemplateType[TemplateWF::kPMT]))) { // invalid
         continue;
      }

      wf = new TemplateWF(i, type);
      wf->fTemplate = (TH2D*)(TH2D*)fin->Get(name.c_str())->Clone(Form("XECPLUFSumWFTemplate_%d", i));
      if (fin->Get(Form("xecsumwftemplate%04d", i))) {
         wf->fTemplateWaveform = new MEGXECDRSWaveform((TH1D*)fin->Get(Form("xecsumwftemplate%04d", i)));
      }
      wf->fSamplingInterval = par_samplingInterval->GetVal();
      wf->fTemplateMean.clear();
      wf->fTemplateUncert.clear();
      for (Int_t iPnt = 0; iPnt < wf->fTemplate->GetNbinsX(); iPnt++) {
         Double_t mean = wf->fTemplate->ProjectionY("_py", iPnt, iPnt + 1)->GetMean();
         Double_t rms = wf->fTemplate->ProjectionY("_py", iPnt, iPnt + 1)->GetRMS();
         rms = TMath::Max(kUncert_MIN, rms);
         wf->fTemplateMean.push_back(mean);
         wf->fTemplateUncert.push_back(rms);
      }

      const Float_t kThreshold = kConstantFraction * (*std::min_element(wf->fTemplateMean.begin(), wf->fTemplateMean.end()));
      for (Int_t iPnt = 0; iPnt < wf->fTemplate->GetNbinsX() - 1; iPnt++) {
         if (wf->fTemplateMean[iPnt] > kThreshold && wf->fTemplateMean[iPnt + 1] < kThreshold) {
            wf->fT0Pnt = iPnt;
            break;
         }
      }
      fvTemplateWF.push_back(wf);
   }
   fInputFileTemplate = fin;

   // Assign template
   for (auto sumwf : fvTotalSumWF) {
      sumwf->fTemplateWF = FindTemplateWF(sumwf->fType);
   }

   // check template waveform
   for (auto sumwf : fvTotalSumWF) {
      if (!sumwf->fTemplateWF) {
         if (sumwf->fType == fvTemplateType[TemplateWF::kSiPM]
             || sumwf->fType == fvTemplateType[TemplateWF::kPMT]) {
            Report(R_ERROR, "Template waveform for total sum waveform is not found.");
         } else {
            Report(R_WARNING, Form("Template waveform for divided analysis (%s) is not found. Use total sum waveform instead.", sumwf->fType.Data()));
            if (sumwf->fType.Contains(fvTemplateType[TemplateWF::kSiPM])) {
               sumwf->fTemplateWF = FindTemplateWF(TemplateWF::kSiPM);
            } else if (sumwf->fType.Contains(fvTemplateType[TemplateWF::kPMT])) {
               sumwf->fTemplateWF = FindTemplateWF(TemplateWF::kPMT);
            }
         }
      }
   }

   // Calculate conversion factor from amplitude to charge
   MEGXECWFRunHeader* wfrh;
   for (auto tempwf : fvTemplateWF) {
      wfrh = gAnalyzer->GetXECWFRunHeaderAt(tempwf->fIndex == TemplateWF::kPMT ? 1 : 0);
      tempwf->fAmpl2Charge = -tempwf->fTemplateWaveform->ChargeIntegration(kTemplateT0 + wfrh->GetChargeIntStart(),
                                                                           kTemplateT0 + wfrh->GetChargeIntEnd(),
                                                                           0.);
   }
}

//______________________________________________________________________________
Int_t MEGTXECPileupUnfolding::PrepareTemplateFit()
{
   // Prepare template fit for deconvolution method

   std::vector<MEGWaveformTemplateFit*> vTemplateFit;
   for (auto tempwf : fvTemplateWF) {
      tempwf->fTemplateFit = new MEGWaveformTemplateFit();
      vTemplateFit.push_back(tempwf->fTemplateFit);
   }

   TString fileName = Form("%s/XECWFTemplateUF_%05d.root",
                           GetSP()->GetReadTemplate()->GetTemplateDirectory().Data(),
                           gAnalyzer->GetXECPileupUnfoldingParameters()->GetTemplateId());
   return MEGDRSWaveform::PrepareTemplate(&vTemplateFit[0]
                                          , fileName.Data()
                                          , "xecsumwftemplate"
                                          , true
                                          , (Int_t)vTemplateFit.size()
                                          , 1
                                          , 0.01
                                          , 4 * nanosecond);
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::Release()
{
   // Release memories

   Option_t* opt = "";
   if (!gAnalyzer->IsROMEAndARGUS()) { // if program mode is NOT 2
      opt = "D";
   }

   for (auto gamma : fvDiffGamma) {
      delete gamma;
   }
   for (auto gamma : fvDeconvGamma) {
      delete gamma;
   }
   for (auto sumwf : fvClusterSumWF) {
      sumwf->Clear(opt);
   }
   for (auto gamma : fvClusterGamma) {
      delete gamma;
   }
   for (auto gamma : fvFADCGamma) {
      delete gamma;
   }
   for (auto gamma : fvRecGamma) {
      delete gamma;
   }
   fvDiffGamma.clear();
   fvDeconvGamma.clear();
   fvClusterSumWF.clear();
   fvClusterGamma.clear();
   fvFADCGamma.clear();
   fvRecGamma.clear();
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::EventSelection()
{
   // Select analyzed event by NPM in RunHeader and trigger mask.

   // Not selected if no photosensor is used.
   const Int_t nPM = gAnalyzer->GetXECRunHeader()->GetNPM();
   if (!nPM) {
      return false;
   }

   // Selection by trigger mask
   auto mask = gAnalyzer->GetEventHeader()->Getmask();
   if (fTRGMask.size()) {
      if (std::find(fTRGMask.begin(), fTRGMask.end(), mask) != fTRGMask.end()) {
         return false;
      }
   }

   // Invalid position
   if (gAnalyzer->GetXECPosLocalFitResultAt(0)->GetxyzAt(0) > 0) {
      return false;
   }

   return true;
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::GetReferenceTime()
{
   // Get reference time, fixed time or reference time used in XECWaveformAnalysis.
   // In case of the same method as XECWaveformAnalysis,
   // Weak LED waveform cftime + 110 ns, PMT summed waveform cftime, or BGO crystal summed waveform cftime are used depending on trigger mask.

   Double_t reftime = MEGWaveform::kInvalidTime;
   if (GetSP()->GetReferenceTime()->GetMethod() == 0) {
      // Use fixed time from SP. Mainly for MC.
      reftime = GetSP()->GetReferenceTime()->GetFixedTime();
   } else {
      auto mask = gAnalyzer->GetEventHeader()->Getmask();
      TString algorithm = gAnalyzer->GetXECRunHeader()->GetRefTimeAlgorithmAt(mask);
      MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(1); // PMT
      reftime = wfrh->GetFixedReferenceTime();

      if (algorithm.Contains("AUXWF")) {
         if (gAnalyzer->GetAUXWaveformAnalysisResultSize() > 5) {
            reftime = gAnalyzer->GetAUXWaveformAnalysisResultAt(4)->Getcftime() + 110 * MEG::nanosecond; // LED MPPC
         } else {
            algorithm = "PMTSUMWFCF";
         }
      }
      if (algorithm.Contains("PMTSUMWFCF")) {
         Int_t iSumWF = XECMakeSumWaveform::FindSumWF("ALL_PMT_LP21");
         if (iSumWF >= 0 &&
             TMath::Abs(gAnalyzer->GetXECSumWaveform()->GetSumWaveformHeightAt(iSumWF)) > 1 * MEG::millivolt &&
             gAnalyzer->GetXECSumWaveform()->GetSumWaveformCftimeAt(iSumWF) < 0) {
            reftime = gAnalyzer->GetXECSumWaveform()->GetSumWaveformCftimeAt(iSumWF);
         } else {
            Report(R_WARNING, Form("Use fixed reftime though method is PMTSUMWFCF, Height: %f", gAnalyzer->GetXECSumWaveform()->GetSumWaveformHeightAt(iSumWF)));
         }
      }
      if (algorithm.Contains("BGOSUMWFCF")) {
         reftime = gAnalyzer->GetBGOSumWaveform()->GetSumWaveformCftimeAt(1); // BGO Crystal
      }
      if (reftime > 0) {
         reftime = wfrh->GetFixedReferenceTime();
      }
   }

   if (fPrint) {
      std::cout << "Reftime: " << reftime << std::endl;
   }
   return reftime;
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::FillAPulse(Bool_t fixParam)
{
   // Fill a pulse for fitting if there is no photon or a photon has too small energy.
   // Selection criteria are
   //   - Trigger mask,
   //   - Nsum2 and no inner peak,
   //   - No main pulse detected,
   //   - No pulse detected in any methods, and
   //   - Detected pulses have smaller amplitude than threshold.

   Bool_t flag(kFALSE);
   auto pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();

   if (fixParam) {
      if (std::find(fFixParamTRGMask.begin(), fFixParamTRGMask.end(),
                    gAnalyzer->GetEventHeader()->Getmask()) != fFixParamTRGMask.end()) {
         flag = kTRUE;
      } else if (gAnalyzer->GetXECFastRecResultAt(0)->Getnsum2() < GetSP()->GetFixParamNsum2Thr() &&
                 !fvClusterGamma.size()) {
         flag = kTRUE;
      }
      if (flag) {
         for (auto sumwf : fvTotalSumWF) {
            sumwf->fvPulse.push_back(new RecPulse(0, kNoReference));
            sumwf->fvPulse[0]->fE = 0;
            sumwf->fvPulse[0]->fEUncert = 0;
            sumwf->fvPulse[0]->fT = 0;
            sumwf->fvPulse[0]->fTUncert = 0;
            sumwf->fvPulse[0]->fFixParameter = kTRUE;
            sumwf->fvPulse[0]->fIsMain = kTRUE;
         }
      }
   } else {
      Bool_t mainFlag(kFALSE);
      for (auto sumwf : fvTotalSumWF) {
         if (!sumwf->fvPulse.size()) {
            flag = kTRUE;
            break;
         }
         if (sumwf->fIndex == 0) flag = kTRUE;
         for (auto pulse : sumwf->fvPulse) {
            if (pulse->fIsMain) mainFlag = kTRUE;
            if (pulse->fE > (sumwf->fIsSiPM ? pParameters->GetNinner2Threshold() : pParameters->GetNpmt2Threshold())) {
               flag = kFALSE;
            }
         }
      } // end of sumwf loop
      if (!mainFlag) flag = kTRUE;
      if (flag) {
         for (auto sumwf : fvTotalSumWF) {
            for (auto pulse : sumwf->fvPulse) SafeDelete(pulse);
            sumwf->fvPulse.clear();
            sumwf->fvPulse.push_back(new RecPulse(0, kNoReference));
            sumwf->fvPulse.back()->fE = 0;
            sumwf->fvPulse.back()->fEUncert = sumwf->fIsSiPM ? pParameters->GetNinner2Threshold() : pParameters->GetNpmt2Threshold();
            sumwf->fvPulse.back()->fT = 0;
            sumwf->fvPulse.back()->fTUncert = 50 * MEG::nanosecond;
            sumwf->fvPulse.back()->fIsMain = kTRUE;
         }
      }
   }

   return flag;
}

//______________________________________________________________________________
template <class TemplateGamma>
void MEGTXECPileupUnfolding::GetSeed(MEGTXECPileupUnfolding::SumWF* sumwf, std::vector<TemplateGamma*>* vGamma, const Int_t refGamma)
{
   // Get seed pulses with the information of signal size and timing.
   // If a pulse time is within coincidence window, the pulse is NOT added for fitting.

   const Double_t kCoincidenceWindow = gAnalyzer->GetXECPileupUnfoldingParameters()->GetCoincidenceWindow();
   for (Int_t iGamma = 0; iGamma < (Int_t)vGamma->size(); iGamma++) {
      TemplateGamma* gamma = vGamma->at(iGamma);
      if (gamma->fInvalid) {
         if (fPrint) {
            std::cout << "Invalid Pulse" << std::endl;
         }
         continue;
      }
      if (gamma->fvT[sumwf->fIsSiPM ? 0 : 1] > 0) { // if invalid time
         continue;
      }

      Int_t minIndex = -1;
      Double_t minDt = 1e10 * MEG::second;
      Double_t pulseTime = 1e10 * MEG::second;
      for (auto pulse : sumwf->fvPulse) {
         Double_t dt = TMath::Abs(pulse->fT + sumwf->fRefTime - gamma->fvT[sumwf->fIsSiPM ? 0 : 1]);
         if (dt < minDt) {
            minDt = dt;
            minIndex = pulse->fPulseIndex;
            pulseTime = pulse->fT;
         }
      }

      if (minDt < kCoincidenceWindow) {
         if (sumwf->fvPulse[minIndex]->fRefGamma / refGamma % 10 == 0) {
            sumwf->fvPulse[minIndex]->fRefGamma += refGamma;
            sumwf->fvPulse[minIndex]->fGammaIndex[refGamma] = gamma->fIndex;
         }
      } else {
         sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), refGamma, refGamma != kClusterGamma ? gamma->fIndex : sumwf->fvPulse.size()));
         sumwf->fvPulse.back()->fRefGamma = refGamma;
         sumwf->fvPulse.back()->fT = gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime;
         sumwf->fvPulse.back()->fTUncert = 5 * MEG::nanosecond;
         sumwf->fvPulse.back()->fE = gamma->fvE[sumwf->fIsSiPM ? 0 : 1];
         sumwf->fvPulse.back()->fEUncert = 1e6; // not for sure
      } // end if tdiff < coincidence window
   } // end of gamma loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::GetSeedFromDiff(MEGTXECPileupUnfolding::SumWF* sumwf,
                                             std::vector<MEGTXECPileupUnfolding::SeedGamma*>* vGamma)
{
   // Get seed pulses from differentiation reference with the information of amplitude and timing.
   // All the diff gammas are seed pulses.

   if (!vGamma->size()) {
      if (fPrint && sumwf->fIsSiPM) {
         printf("No diff gamma is detected.\n");
      }
      return;
   }

   for (auto gamma : *vGamma) {
      if (gamma->fInvalid) {
         if (fPrint) {
            std::cout << "Seed from diff: index " << gamma->fIndex << " Invalid." << std::endl;
         }
         continue;
      }

      sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kDiffGamma, gamma->fIndex));
      sumwf->fvPulse.back()->fRefGamma = kDiffGamma;
      sumwf->fvPulse.back()->fT        = gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime;
      sumwf->fvPulse.back()->fTUncert  = 5 * MEG::nanosecond;
      sumwf->fvPulse.back()->fE        = TMath::Abs(gamma->fvE[sumwf->fIsSiPM ? 0 : 1]);
      sumwf->fvPulse.back()->fEUncert  = 0.2 * sumwf->fvPulse.back()->fE;
      if (sumwf->fvPulse.back()->fT > 30 * MEG::nanosecond) {
         // Not good amplitude estimation for pulse in tail.
         sumwf->fvPulse.back()->fEUncert = 0.5 * sumwf->fvPulse.back()->fE;
      }
      if (sumwf->fIndex == TemplateWF::kSiPM &&
            sumwf->fvPulse.back()->fPulseIndex > 0) {
         if (sumwf->fvPulse.back()->fT - sumwf->fvPulse[0]->fT > -50 * MEG::nanosecond &&
             sumwf->fvPulse.back()->fT - sumwf->fvPulse[0]->fT < 0 * MEG::nanosecond) {
            // Not good amplitude estimation for close off-timing pulses in MPPC.
            sumwf->fvPulse.back()->fE /= 2.;
            sumwf->fvPulse.back()->fEUncert = sumwf->fvPulse.back()->fE;
         }
      }
   } // end of seed gamma loop

   // Main pulse labelled if no main cluster gamma is recorded
   Bool_t mainFlag(kFALSE);
   for (auto gamma : fvClusterGamma) {
      if (gamma->fIsMain) mainFlag = kTRUE;
   }
   if (!mainFlag && sumwf->fIndex == TemplateWF::kSiPM) {
      Int_t    minIdx(0);
      Double_t minDt(1e10);
      for (auto pulse : sumwf->fvPulse) {
         if (minDt > TMath::Abs(pulse->fT)) {
            minDt  = TMath::Abs(pulse->fT);
            minIdx = pulse->fPulseIndex;
         }
      }
      sumwf->fvPulse[minIdx]->fIsMain = kTRUE;
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::GetSeedFromCluster(MEGTXECPileupUnfolding::SumWF* sumwf,
                                                std::vector<MEGTXECPileupUnfolding::ClusterGamma*>* vGamma)
{
   // Get seed pulses from cluster reference with the information of amplitude and timing.
   // Check time difference from existing seed pulses.
   // If judged as the same pulse, DiffGamma information remains.
   // Also, check time difference from existing cluster pulses.
   // If cluster gamma is inverted (= pulse exists in/before baseline region), it is associated with FADCGamma.

   if (!vGamma->size()) {
      if (fPrint && sumwf->fIsSiPM) {
         printf("No cluster gamma is detected.\n");
      }
      return;
   }

   auto pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();
   const Double_t kClusterCoincidenceWindow = pParameters->GetClusterCoincWindow();
   const Double_t kDiffRefCoincidenceWindow = pParameters->GetCoincidenceWindow();

   for (auto gamma : *vGamma) {
      Double_t dt, minDt(1e10 * MEG::second);
      Int_t    minIndex = -1;

      if (gamma->fInvalid) {
         if (fPrint) {
            std::cout << "Seed from cluster: index " << gamma->fIndex << " Invalid." << std::endl;
         }
         continue;
      }

      if (!gamma->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fvPM.size()) {
         continue;
      }

      for (auto pulse : sumwf->fvPulse) {
         dt = TMath::Abs(pulse->fT - (gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime));
         if (dt < minDt) {
            minDt = dt;
            minIndex = pulse->fPulseIndex;
         }
      } // end of checking existing seed pulses

      if (minDt < kDiffRefCoincidenceWindow
            && sumwf->fvPulse[minIndex]->fRefGamma / kClusterGamma % 10 == 0) {
         sumwf->fvPulse[minIndex]->fRefGamma += kClusterGamma;
         sumwf->fvPulse[minIndex]->fGammaIndex[kClusterGamma] = gamma->fIndex;
         sumwf->fvPulse[minIndex]->fIsMain += gamma->fIsMain;
      } else if (minDt < kClusterCoincidenceWindow
            && sumwf->fvPulse[minIndex]->fRefGamma / kClusterGamma % 10 == 1) { // if pulse is already associated with cluster gamma
         if (gamma->fIsMain) {
            sumwf->fvPulse[minIndex]->fGammaIndex[kClusterGamma] = gamma->fIndex;
         }
         sumwf->fvPulse[minIndex]->fIsMain += gamma->fIsMain;
         sumwf->fvPulse[minIndex]->fIsCoincident = kTRUE;
      } else if (gamma->fInverted) { // if pulse in/before baseline
         // "Inverted" cluster gamma should not be the main.
         Bool_t FADCflag(kFALSE);
         for (Int_t index = 0; index < static_cast<Int_t>(sumwf->fvPulse.size()); ++index) {
            auto pulse = sumwf->fvPulse[index];
            if (pulse->fRefGamma == kFADCGamma) {
               pulse->fRefGamma += kClusterGamma;
               pulse->fGammaIndex[kClusterGamma] = gamma->fIndex;
               //pulse->fIsMain += gamma->fIsMain;
               FADCflag = kTRUE;
            }
         }
         if (!FADCflag) {
            sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kClusterGamma, gamma->fIndex));
            sumwf->fvPulse.back()->fRefGamma = kClusterGamma;
            sumwf->fvPulse.back()->fT        = gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime;
            sumwf->fvPulse.back()->fTUncert  = 20 * MEG::nanosecond;
            sumwf->fvPulse.back()->fE        = TMath::Abs(gamma->fvE[sumwf->fIsSiPM ? 0 : 1]);
            sumwf->fvPulse.back()->fEUncert  = 0.3 * sumwf->fvPulse.back()->fE;
            //sumwf->fvPulse.back()->fIsMain   = gamma->fIsMain;
         }
      } else {
         sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kClusterGamma, gamma->fIndex));
         sumwf->fvPulse.back()->fRefGamma = kClusterGamma;
         sumwf->fvPulse.back()->fT        = gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime;
         sumwf->fvPulse.back()->fTUncert  = 5 * MEG::nanosecond;
         sumwf->fvPulse.back()->fE        = TMath::Abs(gamma->fvE[sumwf->fIsSiPM ? 0 : 1]);
         sumwf->fvPulse.back()->fEUncert  = 0.3 * sumwf->fvPulse.back()->fE;
         sumwf->fvPulse.back()->fIsMain   = gamma->fIsMain;
         if (sumwf->fvPulse.back()->fT > 20 * MEG::nanosecond) {
            sumwf->fvPulse.back()->fTUncert = 10 * MEG::nanosecond;
         }
      }
   } // end of seed gamma loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::GetSeedFromFADC(MEGTXECPileupUnfolding::SumWF* sumwf,
                                             std::vector<MEGTXECPileupUnfolding::SeedGamma*>* vGamma)
{
   // Get seed pulses from FADC reference with the information of amplitude and timing.
   // Check time difference from existing seed pulses.
   // If judged as the same pulse, DiffGamma information remains.
   // Do NOT check time difference from existing FADC pulses.

   if (!vGamma->size()) {
      if (fPrint && sumwf->fIsSiPM) {
         printf("No FADC gamma is detected.\n");
      }
      return;
   }

   const Double_t kDiffRefCoincidenceWindow = gAnalyzer->GetXECPileupUnfoldingParameters()->GetCoincidenceWindow();

   for (auto gamma : *vGamma) {
      Double_t dt, minDt(1e10 * MEG::second);
      Int_t    minIndex = -1;

      if (gamma->fInvalid) {
         if (fPrint) {
            std::cout << "Seed from FADC: index " << gamma->fIndex << " Invalid." << std::endl;
         }
         continue;
      }

      for (auto pulse : sumwf->fvPulse) {
         dt = TMath::Abs(pulse->fT - (gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime));
         if (dt < minDt) {
            minDt = dt;
            minIndex = pulse->fPulseIndex;
         }
      } // end of checking existing seed pulses

      if (minIndex < 0) {
         sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kFADCGamma, gamma->fIndex));
         sumwf->fvPulse.back()->fRefGamma = kFADCGamma;
         sumwf->fvPulse.back()->fT        = gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime;
         sumwf->fvPulse.back()->fTUncert  = 20 * MEG::nanosecond;
         sumwf->fvPulse.back()->fE        = TMath::Abs(gamma->fvE[sumwf->fIsSiPM ? 0 : 1]);
         sumwf->fvPulse.back()->fEUncert  = 0.2 * sumwf->fvPulse.back()->fE;
         if (sumwf->fIsSiPM && !fvClusterGamma.size()) sumwf->fvPulse.back()->fIsMain = kTRUE;
      } else {
         if (minDt < kDiffRefCoincidenceWindow
               && sumwf->fvPulse[minIndex]->fRefGamma / kFADCGamma % 10 == 0) {
            sumwf->fvPulse[minIndex]->fRefGamma += kFADCGamma;
            sumwf->fvPulse[minIndex]->fGammaIndex[kFADCGamma] = gamma->fIndex;
         } else {
            sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kFADCGamma, gamma->fIndex));
            sumwf->fvPulse.back()->fRefGamma = kFADCGamma;
            sumwf->fvPulse.back()->fT        = gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - sumwf->fRefTime;
            sumwf->fvPulse.back()->fTUncert  = 5 * MEG::nanosecond;
            sumwf->fvPulse.back()->fE        = TMath::Abs(gamma->fvE[sumwf->fIsSiPM ? 0 : 1]);
            sumwf->fvPulse.back()->fEUncert  = 0.1 * sumwf->fvPulse.back()->fE;
         }
      }
   } // end of seed gamma loop
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::GetSeedFromResidual(Bool_t baselineRegion)
{
   // Get an additional seed pulse from residual waveform.
   // This method focuses on pre-timing and post-timing pileup.

   Bool_t   findResPulseFlag = kFALSE;
   Int_t    pkpnt;
   Double_t tstart, tend, threshold, pkampl, time;
   Double_t height[2];
   for (auto sumwf : fvTotalSumWF) {
      threshold = sumwf->fIsSiPM ? fNinner2Threshold : fNpmt2Threshold;
      if (baselineRegion) {
         tstart = sumwf->fResWaveform->GetTimeMin() + 15 * MEG::nanosecond;
         tend   = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1)->GetBaselineEnd();
      } else {
         tstart = TMath::Max(30 * MEG::nanosecond, sumwf->fResWaveform->GetTimeMin() + 15 * MEG::nanosecond);
         tend   = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1)->GetChargeIntEnd() +
                     gAnalyzer->GetXECPileupUnfoldingParameters()->GetFitMargin();
      }
      if (tstart > tend) continue;
      sumwf->fResWaveform->MinimumPeak(pkampl, pkpnt, tstart, tend);
      time = sumwf->fResWaveform->GetTimeAt(pkpnt);
      if ((height[sumwf->fIndex] = sumwf->fResWaveform->MaximumPeak(tstart, tend) - pkampl) > threshold) {
         findResPulseFlag = kTRUE;
      }
   }

   if (!findResPulseFlag) {
      return kFALSE;
   }

   for (Int_t iSumWF = 0; iSumWF < 2; iSumWF++) {
      auto* sumwf = fvTotalSumWF[iSumWF];
      for (auto pulse : sumwf->fvPulse) {
         pulse->fEUncert = 0.1 * pulse->fE;
      }
      sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kNoReference, sumwf->fvPulse.size()));
      sumwf->fvPulse.back()->fRefGamma = kNoReference;
      sumwf->fvPulse.back()->fT        = time;
      sumwf->fvPulse.back()->fTUncert  = 15 * MEG::nanosecond;
      sumwf->fvPulse.back()->fE        = height[iSumWF];
      sumwf->fvPulse.back()->fEUncert  = 0.2 * sumwf->fvPulse.back()->fE;
   }
   return kTRUE;
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::GetSeedFromChi2()
{
   // Get an additional seed pulse from "chi2" waveform.

   Double_t pkampl;
   Int_t    pkpoint;
   fgChi2Waveform->MaximumPeak(pkampl, pkpoint,
                               fgChi2Waveform->GetTimeMin(), gAnalyzer->GetXECWFRunHeaderAt(1)->GetChargeIntEnd());
   if (pkampl < gAnalyzer->GetXECPileupUnfoldingParameters()->GetChi2PeakThreshold()) {
      return kFALSE;
   }
   Double_t pktime = fgChi2Waveform->GetTimeAt(pkpoint);

   for (Int_t iSumWF = 0; iSumWF < 2; iSumWF++) {
      auto* sumwf = fvTotalSumWF[iSumWF];
      sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kNoReference, sumwf->fvPulse.size()));
      sumwf->fvPulse.back()->fRefGamma = kNoReference;
      sumwf->fvPulse.back()->fT        = pktime;
      sumwf->fvPulse.back()->fTUncert  = 5 * MEG::nanosecond;
      sumwf->fvPulse.back()->fE        = sumwf->fvPulse[0]->fE * 0.5;
      sumwf->fvPulse.back()->fEUncert  = 0.4 * sumwf->fvPulse.back()->fE;
   }
   return kTRUE;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AssignSeedPulseIndex()
{
   // This method sorts fPulseIndex and/or adds new seed pulses.
   // The number of pulses in MPPC and PMT is checked.
   // If the numbers are same, fPulseIndex is sorted by time difference between MPPC and PMT.
   // If different, missing pulses are searched for based on time difference and they are added.

   auto mppcwf = fvTotalSumWF[TemplateWF::kSiPM];
   auto pmtwf  = fvTotalSumWF[TemplateWF::kPMT];

   Int_t    minIdx(-1);
   Double_t dt, minDt(1e10);
   SumWF    *morewf, *fewerwf;
   Bool_t   pulseExists(kFALSE);

   if (mppcwf->fvPulse.size() == pmtwf->fvPulse.size()) {
      // Sort fPulseIndex in MPPC seed pulses detected by Cluster method.
      // Pulse matching with PMT seed pulses is done based on time difference.
      for (auto mppcpulse : mppcwf->fvPulse) {
         if (mppcpulse->fRefGamma != kClusterGamma) {
            continue;
         }
         minDt = 1e10 * MEG::second;
         for (auto pmtpulse : pmtwf->fvPulse) {
            if (pmtpulse->fRefGamma != kClusterGamma) {
               continue;
            }
            dt = TMath::Abs(mppcpulse->fT - pmtpulse->fT);
            if (dt < minDt) {
               minDt = dt;
               minIdx = pmtpulse->fPulseIndex;
            }
         }
         if (minIdx > -1) {
            mppcpulse->fPulseIndex = minIdx;
         }
      } // end of MPPC pulse loop

   } else {
      // fewerwf (morewf) is defined as a waveform sum with fewer (more) seed pulses.
      // Pulses in fewerwf corresponds to pulses in mprewf based on time difference.
      // Some pulses in morewf should not have a corresponding pulse in fewerwf.
      // Add the pulses in fewerwf and then the numbers of pulses in MPPC and PMT are the same.
      if (mppcwf->fvPulse.size() > pmtwf->fvPulse.size()) {
         fewerwf = pmtwf;
         morewf  = mppcwf;
      } else {
         fewerwf = mppcwf;
         morewf  = pmtwf;
      }

      std::set<Int_t> pulseIndexSet;
      for (auto fewerpulse : fewerwf->fvPulse) {
         minDt = 1e10 * MEG::second;
         for (auto morepulse : morewf->fvPulse) {
            if (pulseIndexSet.find(morepulse->fPulseIndex) != pulseIndexSet.end()) {
               continue;
            }
            dt = TMath::Abs(morepulse->fT - fewerpulse->fT);
            if (dt < minDt) {
               minDt = dt;
               minIdx = morepulse->fPulseIndex;
            }
         }
         pulseIndexSet.insert(minIdx);
         if (minIdx >= 0) {
            fewerpulse->fPulseIndex = minIdx;
         }
      }
      for (auto morepulse : morewf->fvPulse) {
         pulseExists = kFALSE;
         for (auto fewerpulse : fewerwf->fvPulse) {
            if (fewerpulse->fPulseIndex == morepulse->fPulseIndex) {
               pulseExists = kTRUE;
               break;
            }
         }
         if (!pulseExists) {
            fewerwf->fvPulse.push_back(new RecPulse(morepulse->fPulseIndex, kNoReference, morepulse->fPulseIndex));
            fewerwf->fvPulse.back()->fE = morepulse->fE;
            fewerwf->fvPulse.back()->fEUncert = fewerwf->fvPulse.back()->fE * 0.5;
            fewerwf->fvPulse.back()->fT = morepulse->fT;
            fewerwf->fvPulse.back()->fTUncert = morepulse->fTUncert;
         }
      }
   }

   // Check unexpected overlap.
   std::unordered_set<Int_t> setIdxBuf;
   for (auto pulse : mppcwf->fvPulse) {
      if (setIdxBuf.find(pulse->fPulseIndex) != setIdxBuf.end()) {
         Report(R_ERROR, "There is an overlop of pulse index %d. Modify source code.", pulse->fPulseIndex);
      } else {
         setIdxBuf.insert(pulse->fPulseIndex);
      }
   }
   setIdxBuf.clear();
   for (auto pulse : pmtwf->fvPulse) {
      if (setIdxBuf.find(pulse->fPulseIndex) != setIdxBuf.end()) {
         Report(R_ERROR, "There is an overlop of pulse index %d. Modify source code.", pulse->fPulseIndex);
      } else {
         setIdxBuf.insert(pulse->fPulseIndex);
      }
   }
   setIdxBuf.clear();
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeTotalWF()
{
   // Fit and unfold raw waveform sums.
   // If reference switch > 0, seed pulses are input from selected references.
   // Unfolding method can be chosen in SP.
   //   - Ones digit: Methods to input seed pulses. 0: Using constant coincidence window. 1: Optimal coincidence window according to references.
   //   - Tens digit: Methods to fit. 0: Independent fit in MPPC and PMT. 1: Simultaneous fit.
   // Unfolded pulses are analyzed in SumWF::WaveformAnalysis.
   // Here, main pulse is defined as residual pulse (raw - all the fitted waveform).
   // Finally, pulses and surplus cluster gammas are filled in RecGamma.

   // Fit and unfold
   auto pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();
   if (!pParameters->GetSimultaneousFitFlag()) {
      for (auto sumwf : fvTotalSumWF) {
         FitAndUnfold(sumwf);
      }
      AssignIndices();
      for (auto sumwf : fvTotalSumWF) {
         ReFitAndUnfold(sumwf);
      }
      InvalidateIgnorableFADCPulses();
   } else {
      SimulFitAndUnfold();
   }

   // Waveform analysis for unfolded pulses
   for (auto sumwf : fvTotalSumWF) {
      sumwf->RemoveInvalidPulse(0, fPrint);
      sumwf->WaveformAnalysis();
      if (fPrint) sumwf->PrintPulse();
   }

   // Fill gamma from unfolded pulses.
   Int_t nGamma = TMath::Min(fvTotalSumWF[TemplateWF::kSiPM]->fvPulse.size(),
                             fvTotalSumWF[TemplateWF::kPMT]->fvPulse.size());
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      fvRecGamma.push_back(new RecGamma(iGamma, fvTotalSumWF[0]->fvPulse[iGamma]->fRefGamma, iGamma));
      fvRecGamma.back()->Resize(fvTotalSumWF.size());
      for (auto sumwf : fvTotalSumWF) {
         auto pulse = sumwf->fvPulse[iGamma];
         fvRecGamma[iGamma]->fvPulse[sumwf->fIndex]       = pulse;
         fvRecGamma[iGamma]->fvNormCharge[sumwf->fIndex]  = sumwf->fNormCharge;
         fvRecGamma[iGamma]->fvE[sumwf->fIndex]           = pulse->fE;
         fvRecGamma[iGamma]->fvEwf[sumwf->fIndex]         = pulse->fEwf;
         fvRecGamma[iGamma]->fvT[sumwf->fIndex]           = pulse->fT + sumwf->fRefTime;
         fvRecGamma[iGamma]->fvChi2[sumwf->fIndex]        = sumwf->fFCN;
         fvRecGamma[iGamma]->fvFitStatus[sumwf->fIndex]   = sumwf->fFitStatus;
         fvRecGamma[iGamma]->fvSaturatedCh[sumwf->fIndex] = sumwf->fvSaturatedCh;
         fvRecGamma[iGamma]->fvDeadCh[sumwf->fIndex]      = sumwf->fvDeadCh;

         if (pParameters->GetReferenceSwitch() / kInputSeed % 10 == kOptimalSeedInput // if pulse associated with cluster gamma
               && sumwf->fIndex == TemplateWF::kSiPM
               && pulse->fGammaIndex[kClusterGamma] > -1) {
            fvRecGamma[iGamma]->fUVW = fvClusterGamma[pulse->fGammaIndex[kClusterGamma]]->fUVW;
         }

         fvRecGamma[iGamma]->fvGammaType[sumwf->fIndex] = (pulse->fRefGamma / kClusterGamma % 10) ? RecGamma::kUnfoldedPL : RecGamma::kAdditionalPL;
      } // end of sumwf loop

      // Fit status and chi2
      if (!pParameters->GetSimultaneousFitFlag()) {
         fvRecGamma[iGamma]->fChi2 = TMath::Max(fvRecGamma[iGamma]->fvChi2[0], fvRecGamma[iGamma]->fvChi2[1]);
         fvRecGamma[iGamma]->fFitStatus = (fvRecGamma[iGamma]->fvFitStatus[0] == SumWF::kConverged &&
                                           fvRecGamma[iGamma]->fvFitStatus[1] == SumWF::kConverged) ? SumWF::kConverged : SumWF::kNotConverged;
      } else {
         fvRecGamma[iGamma]->fChi2 = fgFCN;
         fvRecGamma[iGamma]->fFitStatus = (fgFCN < pParameters->GetChi2Threshold()) ? SumWF::kConverged : SumWF::kNotConverged;
      }

   } // end of gamma loop

   if (!fvRecGamma.size()) {
      Report(R_WARNING, "No gamma is reconstructed.");
      return;
   }

   // 1st gamma is main.
   fvRecGamma[0]->fvGammaType[TemplateWF::kSiPM] = RecGamma::kMain;
   fvRecGamma[0]->fvGammaType[TemplateWF::kPMT]  = RecGamma::kMain;

   // Add on-time gamma to RecGamma.
   CombineRecCluster();

   if (fPrint) {
      for (auto gamma : fvRecGamma) {
         gamma->Print();
      }
      for (auto gamma : fvClusterGamma) {
         gamma->Print();
      }
   }

}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AssignIndices()
{
   // Pulses in total waveforms are unfolded separately between MPPC and PMT so far.
   // Here, MPPC pulses match with PMT pulses, and indices are assigned.

   if (fvTotalSumWF.size() < 2) {
      return;
   }

   auto MPPCSumWF = fvTotalSumWF[TemplateWF::kSiPM];
   auto PMTSumWF = fvTotalSumWF[TemplateWF::kPMT];
   MPPCSumWF->MergeCoincidentPulse();
   PMTSumWF->MergeCoincidentPulse();
   MPPCSumWF->RemoveInvalidPulse(fNinner2Threshold, fPrint);
   PMTSumWF->RemoveInvalidPulse(fNpmt2Threshold, fPrint);
   if (fPrint) {
      std::cout << "Assign indices" << std::endl;
      MPPCSumWF->PrintPulse();
      PMTSumWF->PrintPulse();
   }

   // Find main gamma pair
   // Criteria: MPPC has counterpart in PMT pulse + |T| < 50 ns + nsum2 is reasonably large.
   Double_t minRefTimeDiff = 50 * MEG::nanosecond;
   std::pair<Int_t, Int_t> mainGammaPair = {0, 0};
   Bool_t mainGammaFoundFlag = false;
   for (Int_t iMPPCPulse = 0; iMPPCPulse < (Int_t)MPPCSumWF->fvPulse.size(); iMPPCPulse++) {
      auto pulse_mppc = MPPCSumWF->fvPulse[iMPPCPulse];
      Double_t minTimeDiff = 10 * MEG::nanosecond;
      Int_t iPMTPulse_corr = -1;

      // Find Partner
      for (Int_t iPMTPulse = 0; iPMTPulse < (Int_t)PMTSumWF->fvPulse.size(); iPMTPulse++) {
         auto pulse_pmt = PMTSumWF->fvPulse[iPMTPulse];
         Double_t timediff = TMath::Abs(pulse_mppc->fT - pulse_pmt->fT);
         if (TMath::Abs(pulse_mppc->fT) < 50 * MEG::nanosecond &&
             TMath::Abs(pulse_pmt->fT) < 50 * MEG::nanosecond &&
             pulse_mppc->fE > fNinner2Threshold &&
             pulse_pmt->fE > fNpmt2Threshold &&
             timediff < minTimeDiff
            ) {
            minTimeDiff = timediff;
            iPMTPulse_corr = iPMTPulse;
         }
         if (pulse_mppc->fIsMain && pulse_pmt->fIsMain) {
            iPMTPulse_corr = iPMTPulse;
            break;
         }
      }

      // If best pulse is found
      if (iPMTPulse_corr >= 0) {
         if (TMath::Abs(pulse_mppc->fT) < minRefTimeDiff) {
            minRefTimeDiff = TMath::Abs(pulse_mppc->fT);
            mainGammaPair = {iMPPCPulse, iPMTPulse_corr};
            mainGammaFoundFlag = true;
         }
      }
   }

   Int_t startMPPCPulse = 0;
   if (!mainGammaFoundFlag) {
      if (fPrint) {
         std::cout << "main gamma not found" << std::endl;
      }
   } else {
      startMPPCPulse = 1;
      // Swap main gamma -> Main gamma should be #0
      std::iter_swap(MPPCSumWF->fvPulse.begin(), MPPCSumWF->fvPulse.begin() + mainGammaPair.first);
      std::iter_swap(PMTSumWF->fvPulse.begin(), PMTSumWF->fvPulse.begin() + mainGammaPair.second);
      // Set timing of main gamma
      Double_t time_maingamma = (MPPCSumWF->fvPulse[0]->fT + PMTSumWF->fvPulse[0]->fT) / 2.;
      Double_t timediff_maingamma = TMath::Abs(MPPCSumWF->fvPulse[0]->fT - PMTSumWF->fvPulse[0]->fT);
      MPPCSumWF->fvPulse[0]->fT = time_maingamma;
      PMTSumWF->fvPulse[0]->fT = time_maingamma;
      MPPCSumWF->fvPulse[0]->fTUncert = timediff_maingamma;
      PMTSumWF->fvPulse[0]->fTUncert = timediff_maingamma;
   }

   // Process Remaining pulses
   for (Int_t iMPPCPulse = startMPPCPulse; iMPPCPulse < (Int_t)MPPCSumWF->fvPulse.size(); iMPPCPulse++) {
      auto pulse_mppc = MPPCSumWF->fvPulse[iMPPCPulse];
      Double_t minTimeDiff = 30 * MEG::nanosecond;
      Int_t iPMTPulse_corr = -1;
      // Find Partner
      for (Int_t iPMTPulse = iMPPCPulse; iPMTPulse < (Int_t)PMTSumWF->fvPulse.size(); iPMTPulse++) {
         auto pulse_pmt = PMTSumWF->fvPulse[iPMTPulse];
         Double_t timediff = TMath::Abs(pulse_mppc->fT - pulse_pmt->fT);
         if (timediff < minTimeDiff ||
             (pulse_pmt->fT < PMTSumWF->fSumWaveform->GetTimeMin() && pulse_mppc->fT < PMTSumWF->fSumWaveform->GetTimeMin())) {
            minTimeDiff = timediff;
            iPMTPulse_corr = iPMTPulse;
         }
      }

      // If best pulse is found
      if (iPMTPulse_corr >= 0) {
         // std::cout<<"Consistent pulse found "<<iMPPCPulse<<" "<<iPMTPulse_corr<<std::endl;
         Double_t timing_coincident = (MPPCSumWF->fvPulse[iMPPCPulse]->fT + PMTSumWF->fvPulse[iPMTPulse_corr]->fT) / 2.;
         MPPCSumWF->fvPulse[iMPPCPulse]->fT = timing_coincident;
         MPPCSumWF->fvPulse[iMPPCPulse]->fTUncert = minTimeDiff / 5.;
         PMTSumWF->fvPulse[iPMTPulse_corr]->fT = timing_coincident;
         PMTSumWF->fvPulse[iPMTPulse_corr]->fTUncert = minTimeDiff / 5.;
         if (iMPPCPulse != iPMTPulse_corr) { // PMT pulse swap
            std::iter_swap(PMTSumWF->fvPulse.begin() + iMPPCPulse, PMTSumWF->fvPulse.begin() + iPMTPulse_corr);
         }
      } else {
         // If not, add new pulse from MPPC.
         PMTSumWF->fvPulse.push_back(new RecPulse(PMTSumWF->fvPulse.size(), kNoReference, PMTSumWF->fvPulse.size()));
         std::iter_swap(PMTSumWF->fvPulse.begin() + iMPPCPulse, PMTSumWF->fvPulse.end() - 1);
         PMTSumWF->fvPulse[iMPPCPulse]->fT = pulse_mppc->fT;
         PMTSumWF->fvPulse[iMPPCPulse]->fE = pulse_mppc->fE * 10;
         PMTSumWF->fvPulse[iMPPCPulse]->fTUncert = pulse_mppc->fTUncert;
         PMTSumWF->fvPulse[iMPPCPulse]->fEUncert = pulse_mppc->fEUncert * 10;
      }
   }

   // Remaining PMT pulse
   for (Int_t iPMTPulse = MPPCSumWF->fvPulse.size(); iPMTPulse < (Int_t)PMTSumWF->fvPulse.size(); iPMTPulse++) {
      MPPCSumWF->fvPulse.push_back(new RecPulse(iPMTPulse, kNoReference, iPMTPulse));
      MPPCSumWF->fvPulse[iPMTPulse]->fT = PMTSumWF->fvPulse[iPMTPulse]->fT;
      MPPCSumWF->fvPulse[iPMTPulse]->fE = PMTSumWF->fvPulse[iPMTPulse]->fE * 10;
      MPPCSumWF->fvPulse[iPMTPulse]->fTUncert = PMTSumWF->fvPulse[iPMTPulse]->fTUncert;
      MPPCSumWF->fvPulse[iPMTPulse]->fEUncert = PMTSumWF->fvPulse[iPMTPulse]->fEUncert * 10;
   }

   MPPCSumWF->fvPulse[0]->fIsMain = true;
   PMTSumWF->fvPulse[0]->fIsMain = true;
   // std::cout<<"MPPC pulse: "<<MPPCSumWF->fvPulse.size()<<" PMT: "<<PMTSumWF->fvPulse.size()<<std::endl;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::UpdateChi2Waveform()
{
   // Update chi2 waveform for simultaneous fit.
   // Refer to SimulFCN() for definition of par.

   fgChi2Waveform->SetNPoints(0);

   Int_t minNBin(kDRSBins), thisNBin(0), minIdx(0);
   for (auto sumwf : fvTotalSumWF) {
      thisNBin = sumwf->fSumWaveform->GetNPoints();
      if (thisNBin < minNBin) {
         minNBin = thisNBin;
         minIdx = sumwf->fIndex;
      }
      sumwf->UpdateChi2Waveform();
   }

   fgChi2Waveform->SetTime(fvTotalSumWF[minIdx]->fSumWaveform);

   auto mppcwf = fvTotalSumWF[TemplateWF::kSiPM];
   auto pmtwf  = fvTotalSumWF[TemplateWF::kPMT];

   for (Int_t iPnt = 0; iPnt < minNBin; iPnt++) {
      fgChi2Waveform->SetAmplitudeAt(minNBin - iPnt - 1,
         mppcwf->fChi2Waveform->GetAmplitudeAt(mppcwf->fChi2Waveform->GetNPoints() - iPnt - 1) +
         pmtwf ->fChi2Waveform->GetAmplitudeAt(pmtwf ->fChi2Waveform->GetNPoints() - iPnt - 1));
   }
}

//______________________________________________________________________________
Double_t MEGTXECPileupUnfolding::GetChi2()
{
   // Get chi2 by integrating chi2 waveform out in the range of [TimeMin, ChargeIntEnd].

   Double_t tstart = fgChi2Waveform->GetTimeMin();
   Double_t tend   = gAnalyzer->GetXECWFRunHeaderAt(1)->GetChargeIntEnd();
   Int_t    npnt   = fgChi2Waveform->FindPoint(tend) - fgChi2Waveform->FindPoint(tstart);
   if (npnt <= 0) {
      return 1e10; // Invalid value
   }
   return fgChi2Waveform->ChargeIntegration(tstart, tend, 0) / fgChi2Waveform->GetBinSize() * kDRSInputImpedance / npnt;
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::RemoveInvalidPulses()
{
   // Remove invalid pulses. Criteria are
   //   - Invalid flag in either MPPC or PMT
   //   - Not main in MPPC && not cluster gamma && amplitude < threshold in both MPPC and PMT
   //   - Pulse timing after time window in either MPPC or PMT
   //   - Pulse timing difference within coincidence window
   //   - FADC pulses not affecting charge integration of the main pulse

   auto mppcSumWF = fvTotalSumWF[TemplateWF::kSiPM];
   auto pmtSumWF  = fvTotalSumWF[TemplateWF::kPMT];
   Bool_t removedFlag = kFALSE;
   Short_t npulse = static_cast<Short_t>(mppcSumWF->fvPulse.size());
   if (npulse <= 1) {
      return kFALSE;
   }

   Short_t ipulse(0), jpulse(0);

   // Flag invalid based on pulse timing
   mppcSumWF->PulseTimeBasedInvalidation();
   pmtSumWF->PulseTimeBasedInvalidation();

   // Flag invalid for ignorable FADC pulses
   InvalidateIgnorableFADCPulses();

   while (mppcSumWF->fvPulse.size() > 1) {
      if ((mppcSumWF->fvPulse[ipulse]->fIsInvalid || pmtSumWF->fvPulse[ipulse]->fIsInvalid) ||
          (!mppcSumWF->fvPulse[ipulse]->fIsMain &&
           (mppcSumWF->fvPulse[ipulse]->fGammaIndex[kClusterGamma] == -1 && pmtSumWF->fvPulse[ipulse]->fGammaIndex[kClusterGamma] == -1) &&
           mppcSumWF->fvPulse[ipulse]->fE < fNinner2Threshold && pmtSumWF->fvPulse[ipulse]->fE < fNpmt2Threshold)) {
         if (fPrint) {
            printf("Pulse %d removed. MPPC ref: %d, MPPC E: %g, MPPC t: %g. PMT ref: %d, PMT E: %g, PMT t: %g\n",
                   jpulse, mppcSumWF->fvPulse[ipulse]->fRefGamma, mppcSumWF->fvPulse[ipulse]->fE, mppcSumWF->fvPulse[ipulse]->fT,
                   pmtSumWF->fvPulse[ipulse]->fRefGamma, pmtSumWF->fvPulse[ipulse]->fE, pmtSumWF->fvPulse[ipulse]->fT);
         }
         SafeDelete(mppcSumWF->fvPulse[ipulse]);
         mppcSumWF->fvPulse.erase(mppcSumWF->fvPulse.begin() + ipulse);
         SafeDelete(pmtSumWF->fvPulse[ipulse]);
         pmtSumWF->fvPulse.erase(pmtSumWF->fvPulse.begin() + ipulse);
         removedFlag = kTRUE;
      } else {
         if (ipulse != mppcSumWF->fvPulse[ipulse]->fPulseIndex && ipulse != pmtSumWF->fvPulse[ipulse]->fPulseIndex) {
            mppcSumWF->fvPulse[ipulse]->fPulseIndex = ipulse;
            pmtSumWF->fvPulse[ipulse]->fPulseIndex = ipulse;
         }
         ipulse++;
      }
      jpulse++;
      if (jpulse >= npulse) {
         break;
      }
   }

   return removedFlag;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::InvalidateIgnorableFADCPulses()
{
   // Flag invalid for FADC pulses not affecting the charge integration of the main pulse.
   // The criteria are
   //   - Reference is only FADC waveform analysis,
   //   - Pulse timing is before DRS time window, and
   //   - An amplitude at the first bin is within baseline for both MPPC and PMT.

   if (fvTotalSumWF[TemplateWF::kSiPM]->fvPulse.size() != fvTotalSumWF[TemplateWF::kPMT]->fvPulse.size()) {
      Report(R_ERROR, "The number of pulses differs between MPPC and PMT unexpectedly. Debug the code.");
      return;
   }

   for (Short_t iPulse = 0; iPulse < static_cast<Short_t>(fvTotalSumWF[TemplateWF::kSiPM]->fvPulse.size()); ++iPulse) {
      auto pulse = fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[iPulse];
      if (pulse->fGammaIndex[kFADCGamma] > -1
            && pulse->fT < fvTotalSumWF[TemplateWF::kSiPM]->fSumWaveform->GetTimeMin()
            && fvTotalSumWF[TemplateWF::kSiPM]->fSumWaveform->GetAmplitudeAt(1) - fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[0]->fBase
                  > -fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[0]->fBaseUncert
            && fvTotalSumWF[TemplateWF::kPMT]->fSumWaveform->GetAmplitudeAt(1) - fvTotalSumWF[TemplateWF::kPMT]->fvPulse[0]->fBase
                  > -fvTotalSumWF[TemplateWF::kPMT]->fvPulse[0]->fBaseUncert) {
         pulse->fIsInvalid = kTRUE;
         fvTotalSumWF[TemplateWF::kPMT]->fvPulse[iPulse]->fIsInvalid = kTRUE;
      }
   }
}

//______________________________________________________________________________
Float_t MEGTXECPileupUnfolding::GetNpho(const Int_t iPM, const Int_t index)
{
   // Get Npho for the i-th pulse based on timing difference.

   auto pClusterInfo2 = gAnalyzer->GetXECClusterInfo2At(iPM);
   auto pPMCluster = gAnalyzer->GetXECPMClusterAt(pClusterInfo2->Getclusterid());
   auto pTimeFit = gAnalyzer->GetXECTimeFitResultAt(0);

   Float_t npho = pPMCluster->GetnphoAt(0);
   Float_t tpm  = pPMCluster->GettpmAt(0);
   if (pTimeFit->GettdelaySize()) {
      tpm -= pTimeFit->GettdelayAt(iPM);
   }

   Float_t tdiff(1e10), mintdiff(1e10);
   Int_t minIdx(-1);
   Short_t sumwfIdx = gAnalyzer->GetXECPMRunHeaderAt(iPM)->GetIsSiPM() ? 0 : 1;

   for (Int_t gammaIdx = 0; gammaIdx < static_cast<Int_t>(fvRecGamma.size()); ++gammaIdx) {
      auto gamma = fvRecGamma[gammaIdx];

      if (gamma->fvGammaType[sumwfIdx] == RecGamma::kCoincidencePL) continue;

      //std::cout << tpm << " " << gamma->fvT[sumwfIdx] << " " << gammaIdx << std::endl;
      tdiff = TMath::Abs(tpm - gamma->fvT[sumwfIdx]);
      if (tdiff < mintdiff) {
         mintdiff = tdiff;
         minIdx = gammaIdx;
      }
   } // end of gamma loop

   if (minIdx == index) {
      return npho;
   } else {
      return 0.;
   }

#if 0
   // Unfolded Npho is corrected by mainNsum/rawNsum.

   Float_t npho = 0.;

   MEGXECPMCluster *pPMCluster = gAnalyzer->GetXECPMClusterAt(iPM);
   if (pPMCluster) {
      npho = pPMCluster->GetnphoAt(0);
   }

   // Correct it by ratio of iGamma to sum of amplitude of reconstructed gammas
   MEGXECPMRunHeader *pmrh = gAnalyzer->GetXECPMRunHeaderAt(iPM);
   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(pmrh->GetIsSiPM() ? 0 : 1);
   Float_t cftime = fvTotalSumWF[pmrh->GetIsSiPM() ? 0 : 1]->GetConstantFractionTime();
   if (cftime + wfrh->GetChargeIntEnd() > fvTotalSumWF[pmrh->GetIsSiPM() ? 0 : 1]->fSumWaveform->GetTimeMax()) {
      cftime = 0.0;
   }
   Double_t tstart_baseline = TMath::Max(fvTotalSumWF[pmrh->GetIsSiPM() ? 0 : 1]->fSumWaveform->GetTimeMin(), wfrh->GetBaselineStart());
   Double_t tend_baseline = wfrh->GetBaselineEnd();
   if (tstart_baseline > tend_baseline) {
      tend_baseline = tstart_baseline +  wfrh->GetBaselineEnd() - wfrh->GetBaselineStart();
   }
   Double_t baseline_raw = fvTotalSumWF[pmrh->GetIsSiPM() ? 0 : 1]->fSumWaveform->
                           CalculateBaseline(tstart_baseline, tend_baseline);
   Double_t baseline_tmpl = fvTotalSumWF[pmrh->GetIsSiPM() ? 0 : 1]->fMainWaveform->
                            CalculateBaseline(tstart_baseline, tend_baseline);
   Float_t rawNsum  = fvTotalSumWF[pmrh->GetIsSiPM() ? 0 : 1]->fSumWaveform->
                      ChargeIntegration(wfrh->GetChargeIntStart(),
                                        wfrh->GetChargeIntEnd(), baseline_raw);
   Float_t tmplNsum = fvTotalSumWF[pmrh->GetIsSiPM() ? 0 : 1]->fMainWaveform->
                      ChargeIntegration(wfrh->GetChargeIntStart(),
                                        wfrh->GetChargeIntEnd(), baseline_tmpl);
   if (rawNsum > 0) {
      return npho * tmplNsum / rawNsum;
   } else {
      return npho;
   }
#endif
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FillResult()
{
   // Fill reconstructed result.

   const Int_t nGamma = fvRecGamma.size();
   RecGamma* gamma;

   /* ------------- Set event status. ----------------*/
   Int_t evstat = kUnfolded;
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      gamma = fvRecGamma[iGamma];
      if (gamma->fFitStatus == SumWF::kNotConverged) {
         evstat = kNotConverged;
      }
      for (auto type : gamma->fvGammaType) {
         if (evstat == kUnfolded && type == RecGamma::kCoincidencePL) {
            evstat = kCoincidence;
         }
      }
   }
   if (nGamma == 1 && evstat == kUnfolded) {
      evstat = kNoPileup;
   }

   // check DL
   for (auto gamma : fvClusterGamma) {
      if (evstat != kNotConverged && gamma->fNoPulse && gamma->fStatus == MEGTXECPileupClustering::kDLPileup) {
         // DL found pileups, but no pulse was found in waveform
         evstat = kDLRejected;
      }
      if (evstat == kNoPileup && gamma->fStatus == MEGTXECPileupClustering::kDLPileup) {
         // DL found pileups, but no pulse was found by peak search
         evstat = kDLRejected;
      }
   }

   std::map<Int_t, std::vector<Double_t>> vRefTime;
   for (auto gamma : fvRecGamma) {
      const Int_t nSumWF = gamma->fvGammaType.size();
      for (Int_t iSumWF = 0; iSumWF < nSumWF; iSumWF++) {
         vRefTime[iSumWF].push_back(gamma->fvT[iSumWF]);
      }
   }

   /* ------------- Print event status. ----------------*/
   if (fPrint) {
      std::cout << "Event status : " << evstat << std::endl;
   }

   /* ------------- Fill result. ----------------*/
   gAnalyzer->SetXECPileupUnfoldingResultSize(nGamma);
   MEGXECPileupUnfoldingResult* pPLUFResult;
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      pPLUFResult = gAnalyzer->GetXECPileupUnfoldingResultAt(iGamma);
      gamma = fvRecGamma[iGamma];

      pPLUFResult->Setevstat(evstat);
      for (Int_t i = 0; i < 3; i++) {
         pPLUFResult->SetuvwAt(i, gamma->fUVW[i]);
      }
      pPLUFResult->Setdistance(gamma->fDistanceToMain);

      const Int_t nSumWF = gamma->fvGammaType.size();
      pPLUFResult->SettypeSize(nSumWF);
      pPLUFResult->SetfitstatSize(nSumWF);
      pPLUFResult->SetmethodSize(nSumWF);
      pPLUFResult->SettimeSize(nSumWF);
      pPLUFResult->Setnsum2Size(nSumWF);
      pPLUFResult->Setnsum2wfSize(nSumWF);
      pPLUFResult->Setchi2Size(nSumWF + 1); // + simultaneous fit

      for (Int_t iSumWF = 0; iSumWF < nSumWF; iSumWF++) {
         pPLUFResult->SettypeAt(iSumWF, gamma->fvGammaType[iSumWF]);
         pPLUFResult->SetfitstatAt(iSumWF, gamma->fvFitStatus[iSumWF]);
         if (gamma->fvPulse[iSumWF]) {
            pPLUFResult->SetmethodAt(iSumWF, gamma->fvPulse[iSumWF]->fRefGamma);
         } else {
            pPLUFResult->SetmethodAt(iSumWF, -1);
         }
         pPLUFResult->SettimeAt(iSumWF, gamma->fvT[iSumWF]);
         Double_t nsum2 = 0;
         Double_t nsum2wf = 0;
         if (gamma->fvNormCharge[iSumWF] > 0) {
            nsum2   = gamma->fvNormCharge[iSumWF] * gamma->fvE[iSumWF];
            nsum2wf = gamma->fvNormCharge[iSumWF] * gamma->fvEwf[iSumWF];
         }

         // add saturated PMs
         Double_t nsum2_saturated = 0;
         for (auto pm : gamma->fvSaturatedCh[iSumWF]) {
            MEGXECEnePMWeightResult *pEnePMWeightResult = gAnalyzer->GetXECEnePMWeightResultAt(pm);
            if (pEnePMWeightResult) {
               nsum2_saturated += pEnePMWeightResult->GetweightAt(0) * GetNpho(pm, iGamma);
            }
         }
         nsum2 += nsum2_saturated;
         nsum2wf += nsum2_saturated;
         if (evstat != kNotConverged) {
            pPLUFResult->Setnsum2At(iSumWF, nsum2);
         } else {
            pPLUFResult->Setnsum2At(iSumWF, nsum2wf);
         }

         pPLUFResult->Setnsum2wfAt(iSumWF, nsum2wf);

         // chi2
         pPLUFResult->Setchi2At(iSumWF, gamma->fvChi2[iSumWF]);
         pPLUFResult->Setchi2At(2, fgFCN);
      } // end of SumWF loop

      pPLUFResult->SetpmlistSize(gamma->fvPM.size());
      for (Int_t iPM = 0; iPM < static_cast<Int_t>(gamma->fvPM.size()); iPM++) {
         pPLUFResult->SetpmlistAt(iPM, gamma->fvPM[iPM]);
      }
   } // end of gamma loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::DrawWaveform()
{
   // If verbose level is proper, waveforms are drawn in canvases.

   /* ------------- Draw ----------------*/
   fStyle->cd();
   Int_t iSumWF = 0;
   for (auto sumwf : fvTotalSumWF) {
      Int_t iCanvas = sumwf->fIndex / 2;
      Int_t iPad = sumwf->fIndex % 2 + 1;
      if (iCanvas >= (Int_t)fvTotalSumWFCanvas.size()) {
         fvTotalSumWFCanvas.push_back(new TCanvas(Form("cXECPLUFTotalSumWF_%d", sumwf->fIndex),
                                                  Form("cXECPLUFTotalSumWF_%d", sumwf->fIndex),
                                                  1200, 600));
         fvTotalSumWFCanvas.back()->Divide(2, 2);
         fvTotalSumWFCanvas.back()->cd(3);
         fvTotalSumWFCanvas.back()->GetPad(3)->SetLogy();
         fvTotalSumWFCanvas.back()->cd(4);
         fvTotalSumWFCanvas.back()->GetPad(4)->SetLogy();
      }

      fvTotalSumWFCanvas[iCanvas]->cd(iPad);
      if (sumwf->fSumWaveform && sumwf->fSumWaveform->GetNPoints() > 0) {
         sumwf->fSumWaveform->SetTitle(";time (sec);amplitude (a.u.)");
         sumwf->fSumWaveform->Draw();
         fvSumWFTmpl[sumwf->fIndex]->fSumWaveform->SetLineColor(kViolet);
         fvSumWFTmpl[sumwf->fIndex]->fSumWaveform->Draw("same");
      }
      if (sumwf->fvPulse.size() && sumwf->fvPulse[0]->fFitWaveform->GetNPoints() > 0) {
         for (auto pulse : sumwf->fvPulse) {
            if (pulse->fIsMain) {
               pulse->fFitWaveform->SetLineWidth(2);
            }
            pulse->fFitWaveform->SetLineColor(pulse->fPulseIndex + 2);
            pulse->fFitWaveform->Draw("same");
         }
      }
      if (sumwf->fMVAWaveform && sumwf->fMVAWaveform->GetNPoints() > 0) {
         sumwf->fMVAWaveform->SetLineColor(kCyan + 1);
         //sumwf->fMVAWaveform->SetLineWidth(2);
         //sumwf->fMVAWaveform->Draw("same");
         if (sumwf->fPeakSearchMethod == kSearchInMVA) {
            sumwf->fThrLine->SetLineColor(kGreen + 1);
         }
      }
      if (sumwf->fDiffWaveform && sumwf->fDiffWaveform->GetNPoints() > 0) {
         sumwf->fDiffWaveform->SetLineColor(kOrange + 1);
         sumwf->fDiffWaveform->SetLineWidth(2);
         sumwf->fDiffWaveform->Draw("same");
         if (sumwf->fPeakSearchMethod == kSearchInDiff) {
            sumwf->fThrLine->SetLineColor(kViolet);
         }
      }
      if (sumwf->fResWaveform && sumwf->fResWaveform->GetNPoints()) {
         sumwf->fResWaveform->SetLineColor(kGray + 2);
         sumwf->fResWaveform->SetLineWidth(2);
         sumwf->fResWaveform->Draw("same");
         if (sumwf->fPeakSearchMethod == kSearchInRes) {
            sumwf->fThrLine->SetLineColor(46);
         }
      }
      if (sumwf->fThrLine && sumwf->fPeakSearchThreshold < 0) {
         sumwf->fThrLine->SetX1(sumwf->fSumWaveform->GetTimeMin());
         sumwf->fThrLine->SetY1(sumwf->fPeakSearchThreshold);
         sumwf->fThrLine->SetX2(sumwf->fSumWaveform->GetTimeMax());
         sumwf->fThrLine->SetY2(sumwf->fPeakSearchThreshold);
         sumwf->fThrLine->SetLineStyle(7);
         sumwf->fThrLine->SetLineWidth(2);
         sumwf->fThrLine->Draw("same");
      }

      fvTotalSumWFCanvas[iCanvas]->cd(iPad + 2);
      if (sumwf->fChi2Waveform && sumwf->fChi2Waveform->GetNPoints() > 0) {
         sumwf->fChi2Waveform->SetTitle(";time (sec);#chi^{2}");
         sumwf->fChi2Waveform->SetMinimum(1e-1);
         sumwf->fChi2Waveform->SetMaximum(1e3);
         sumwf->fChi2Waveform->Draw();
         if (sumwf->fChi2ThrLine && sumwf->fChi2Threshold > 0) {
            sumwf->fChi2ThrLine->SetX1(sumwf->fChi2Waveform->GetTimeMin());
            sumwf->fChi2ThrLine->SetY1(sumwf->fChi2Threshold);
            sumwf->fChi2ThrLine->SetX2(sumwf->fChi2Waveform->GetTimeMax());
            sumwf->fChi2ThrLine->SetY2(sumwf->fChi2Threshold);
            sumwf->fChi2ThrLine->SetLineColor(kRed);
            sumwf->fChi2ThrLine->SetLineStyle(7);
            sumwf->fChi2ThrLine->SetLineWidth(2);
            sumwf->fChi2ThrLine->Draw("same");
         }
      }
      iSumWF++;

      fvTotalSumWFCanvas[iCanvas]->Modified();
      fvTotalSumWFCanvas[iCanvas]->Update();
   } // end of SumWF loop


   // Draw waveforms of each cluster
   fStyle->cd();
   const Int_t nGamma = fvClusterGamma.size();
   Int_t jGamma = 0;
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      auto gamma = fvClusterGamma[iGamma];
      //if (gamma->fInvalid) continue;
      if (jGamma >= (Int_t)fvClusterSumWFCanvas.size()) {
         fvClusterSumWFCanvas.push_back(new TCanvas(Form("cXECPLUFClusterSumWF_gamma%d", jGamma),
                                                    Form("cXECPLUFClusterSumWF_gamma%d", jGamma),
                                                    1200, 600));
         fvClusterSumWFCanvas[jGamma]->Divide(2, 2);
         fvClusterSumWFCanvas[jGamma]->cd(3);
         fvClusterSumWFCanvas[jGamma]->GetPad(3)->SetLogy();
         fvClusterSumWFCanvas[jGamma]->cd(4);
         fvClusterSumWFCanvas[jGamma]->GetPad(4)->SetLogy();
      }

      Int_t iSumWF = 0;
      for (auto sumwf : gamma->fvSumWF) {
         fvClusterSumWFCanvas[jGamma]->cd(iSumWF + 1);
         sumwf->fSumWaveform->SetTitle(Form("#gamma id = %d;time (sec);amplitude (a.u.)", gamma->fIndex));
         if (sumwf->fSumWaveform->GetNPoints() > 0) {
            sumwf->fSumWaveform->Draw();
         }
         if (sumwf->fvPulse.size() && sumwf->fvPulse[0]->fFitWaveform->GetNPoints() > 0) {
            sumwf->fvPulse[0]->fFitWaveform->SetLineWidth(2);
            for (auto pulse : sumwf->fvPulse) {
               pulse->fFitWaveform->SetLineColor(pulse->fPulseIndex + 2);
               pulse->fFitWaveform->Draw("same");
            }
         }
         if (sumwf->fResWaveform && sumwf->fResWaveform->GetNPoints() > 0) {
            sumwf->fResWaveform->SetLineColor(kGray + 2);
            sumwf->fResWaveform->SetLineWidth(2);
            sumwf->fResWaveform->Draw("same");
            if (sumwf->fPeakSearchMethod == kSearchInRes) {
               sumwf->fThrLine->SetLineColor(46);
            }
         }
         if (sumwf->fMVAWaveform && sumwf->fMVAWaveform->GetNPoints() > 0) {
            sumwf->fMVAWaveform->SetLineColor(kCyan + 1);
            //sumwf->fMVAWaveform->SetLineWidth(2);
            sumwf->fMVAWaveform->Draw("same");
            if (sumwf->fPeakSearchMethod == kSearchInMVA) {
               sumwf->fThrLine->SetLineColor(kGreen + 1);
            }
         }
         if (sumwf->fDiffWaveform && sumwf->fDiffWaveform->GetNPoints() > 0) {
            sumwf->fDiffWaveform->SetLineColor(kOrange + 1);
            //sumwf->fDiffWaveform->SetLineWidth(2);
            sumwf->fDiffWaveform->Draw("same");
            if (sumwf->fPeakSearchMethod == kSearchInDiff) {
               sumwf->fThrLine->SetLineColor(kViolet);
            }
         }
         if (sumwf->fThrLine && sumwf->fPeakSearchThreshold < 0) {
            sumwf->fThrLine->SetX1(sumwf->fSumWaveform->GetTimeMin());
            sumwf->fThrLine->SetY1(sumwf->fPeakSearchThreshold);
            sumwf->fThrLine->SetX2(sumwf->fSumWaveform->GetTimeMax());
            sumwf->fThrLine->SetY2(sumwf->fPeakSearchThreshold);
            sumwf->fThrLine->SetLineStyle(7);
            sumwf->fThrLine->SetLineWidth(2);
            sumwf->fThrLine->Draw("same");
         }

         if (sumwf->fChi2Waveform && sumwf->fChi2Waveform->GetNPoints() > 0) {
            fvClusterSumWFCanvas[jGamma]->cd(iSumWF + 3);
            sumwf->fChi2Waveform->SetTitle(";time (sec);#chi^{2}");
            sumwf->fChi2Waveform->SetMinimum(1e-1);
            sumwf->fChi2Waveform->SetMaximum(1e3);
            sumwf->fChi2Waveform->Draw();
            if (sumwf->fChi2ThrLine && sumwf->fChi2Threshold > 0) {
               sumwf->fChi2ThrLine->SetX1(sumwf->fChi2Waveform->GetTimeMin());
               sumwf->fChi2ThrLine->SetY1(sumwf->fChi2Threshold);
               sumwf->fChi2ThrLine->SetX2(sumwf->fChi2Waveform->GetTimeMax());
               sumwf->fChi2ThrLine->SetY2(sumwf->fChi2Threshold);
               sumwf->fChi2ThrLine->SetLineColor(kRed);
               sumwf->fChi2ThrLine->SetLineStyle(7);
               sumwf->fChi2ThrLine->SetLineWidth(2);
               sumwf->fChi2ThrLine->Draw("same");
            }
         }
         iSumWF++;
      } // end of SumWF loop

      fvClusterSumWFCanvas[jGamma]->Modified();
      fvClusterSumWFCanvas[jGamma++]->Update();
   } // end of cluster gamma loop

}

//______________________________________________________________________________
MEGTXECPileupUnfolding::SumWF* MEGTXECPileupUnfolding::FindSumWF(const Int_t type)
{
   for (auto sumWF : fvTotalSumWF) {
      if (sumWF->fType == fvTemplateType[type]) {
         return sumWF;
      }
   }
   return NULL;
}

//______________________________________________________________________________
MEGTXECPileupUnfolding::SumWF* MEGTXECPileupUnfolding::FindSumWF(const TString type)
{
   for (auto sumWF : fvTotalSumWF) {
      if (sumWF->fType == type) {
         return sumWF;
      }
   }
   return NULL;
}


//______________________________________________________________________________
MEGTXECPileupUnfolding::TemplateWF* MEGTXECPileupUnfolding::FindTemplateWF(const Int_t type)
{
   for (auto templateWF : fvTemplateWF) {
      if (templateWF->fType == fvTemplateType[type]) {
         return templateWF;
      }
   }
   return NULL;
}

//______________________________________________________________________________
MEGTXECPileupUnfolding::TemplateWF* MEGTXECPileupUnfolding::FindTemplateWF(const TString type)
{
   for (auto templateWF : fvTemplateWF) {
      if (templateWF->fType == type) {
         return templateWF;
      }
   }
   return NULL;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FitAndUnfold(MEGTXECPileupUnfolding::SumWF* sumwf)
{
   // Main fitting method.
   // Get seed pulses depending on reference switch and fit waveform.

   if (!sumwf->fvPM.size()) {
      return;
   }

   auto pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();

   if (pParameters->GetReferenceSwitch() == kNoReference) {
      FitMainGamma(sumwf);
      FitPileupGammaOnTime(sumwf);
      FitPileupGammaInBaselineRegion(sumwf);
      FitPileupGammaInChargeIntegrationRegion(sumwf);
   } else {

      if (std::find(fFixParamTRGMask.begin(), fFixParamTRGMask.end(),
                    gAnalyzer->GetEventHeader()->Getmask()) != fFixParamTRGMask.end()) {
         sumwf->fvPulse.push_back(new RecPulse(0, kNoReference));
         sumwf->fvPulse[0]->fE = 0;
         sumwf->fvPulse[0]->fEUncert = 0;
         sumwf->fvPulse[0]->fT = 0;
         sumwf->fvPulse[0]->fTUncert = 0;
         sumwf->fvPulse[0]->fFixParameter = true;
         sumwf->fvPulse[0]->fIsMain = true;
      } else {
         // Initialize pulse
         switch (pParameters->GetReferenceSwitch() / kInputSeed % 10) {
         case kConstantWindow:
            GetSeed(sumwf, &fvDiffGamma, kDiffGamma);
            GetSeed(sumwf, &fvDeconvGamma, kDeconvGamma);
            GetSeed(sumwf, &fvFADCGamma, kFADCGamma);
            GetSeed(sumwf, &fvClusterGamma, kClusterGamma);
            break;

         case kOptimalSeedInput:
            GetSeedFromDiff(sumwf, &fvDiffGamma);
            GetSeedFromFADC(sumwf, &fvFADCGamma);
            GetSeedFromCluster(sumwf, &fvClusterGamma);
            break;
         }

         if (!sumwf->fvPulse.size()) {
            sumwf->fvPulse.push_back(new RecPulse(0, kNoReference));
         }

         // Relax constraint
         for (auto pulse : sumwf->fvPulse) {
            pulse->fEUncert = TMath::Max(pulse->fE, pulse->fEUncert * 10);
            if (pulse->fT < sumwf->fSumWaveform->GetTimeMin() + 50 * MEG::nanosecond) { // Before DRS window
               pulse->fTUncert = 40 * MEG::nanosecond;
            } else { // Normal pulse
               pulse->fTUncert = 5 * MEG::nanosecond;
            }
         }
      } // end if trigger type is pedestal

      if (fPrint) {
         std::cout << "Fit Initial" << std::endl;
         sumwf->PrintPulse();
      }

      // Fit sum waveform
      Double_t fitstart;
      Double_t fitend;
      sumwf->GetFitRegion(fitstart, fitend);
      sumwf->SetBaselineConstraint();
      sumwf->SetMainGammaConstraint();
      sumwf->FitSumWF({fitstart, fitend}, fFitResult);
      sumwf->UpdateFitWaveforms();
      sumwf->UpdateChi2Waveform();
      sumwf->UpdateResWaveform();

      // Find remaining pulses
      Double_t threshold = sumwf->fIsSiPM ? fNinner2Threshold : fNpmt2Threshold;
      if (sumwf->GetResidualPulseHeight() > threshold) {
         // Check pileup in baseline region
         Int_t nPulse = sumwf->fvPulse.size();
         FitPileupGammaInBaselineRegion(sumwf, true);
         if ((Int_t)sumwf->fvPulse.size() > nPulse) {
            sumwf->fvPulse.back()->fGammaIndex[kNoReference] = 0;
            sumwf->fvPulse.back()->fRefGamma = kNoReference;
         }

         // Check pileup in charge integration region
         nPulse = sumwf->fvPulse.size();
         FitPileupGammaInChargeIntegrationRegion(sumwf);
         if ((Int_t)sumwf->fvPulse.size() > nPulse) {
            sumwf->fvPulse.back()->fGammaIndex[kNoReference] = 0;
            sumwf->fvPulse.back()->fRefGamma = kNoReference;
         }
      }
   } // end of reference switch

   sumwf->CheckConversion();
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FitMainGamma(MEGTXECPileupUnfolding::SumWF* sumwf)
{
   // Fit main pulse (= pulse in t0).

   if (!sumwf->fvPM.size()) {
      return;
   }

   for (auto pulse : sumwf->fvPulse) {
      delete pulse;
   }
   sumwf->fvPulse.clear();

   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);
   const std::vector<Double_t> analysisRegion = {-15 * MEG::nanosecond, 50 * MEG::nanosecond};

   /* ------------- 1 Gamma Fit ----------------*/
   sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size(), kNoReference, 0));
   sumwf->fvPulse.back()->fE          = sumwf->fSumWaveform->MinimumPeak(analysisRegion[0], analysisRegion[1]);
   sumwf->fvPulse.back()->fEUncert    = 2e-2 * sumwf->fvPulse.back()->fE;
   sumwf->fvPulse.back()->fBase       = sumwf->fSumWaveform->CalculateBaseline(wfrh->GetBaselineStart(), wfrh->GetBaselineEnd());
   sumwf->fvPulse.back()->fBaseUncert = sumwf->fSumWaveform->CalculateRMS(wfrh->GetBaselineStart(), wfrh->GetBaselineEnd());
   sumwf->fvPulse.back()->fT          = 0;
   sumwf->fvPulse.back()->fTUncert    = 10. * MEG::nanosecond;
   sumwf->FitSumWF(analysisRegion, fFitResult);
   sumwf->UpdateFitWaveforms();
   sumwf->UpdateChi2Waveform();
   sumwf->UpdateResWaveform();
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FitPileupGammaOnTime(MEGTXECPileupUnfolding::SumWF* sumwf)
{
   // Search for peak in chi2 waveform in the range of [-15 ns, 50 ns].
   // If peaks are found, new pulses are added to fit waveform.

   if (!sumwf->fvPM.size()) {
      return;
   }
   if (!sumwf->fvPulse.size()) {
      Report(R_WARNING, "No pulse is found. Fit main gamma beforehand.");
      return;
   }

   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);
   std::map<Double_t, Int_t, std::greater<Double_t>> vAmpl;

   /* ------------- Check Chi2 of 1 Gamma Fit in Main Gamma region.------------*/
   sumwf->PeakSearchInChi2({-15 * MEG::nanosecond, 50 * MEG::nanosecond}, vAmpl);
   if (fPrint) {
      std::cout << "Main Gamma region" << std::endl;
      for (auto el : vAmpl) {
         std::cout << el.first << " " << el.second << " " << sumwf->fSumWaveform->GetTimeAt(el.second) << std::endl;
      }
   }
   // If other pulse is found in Main Gamma region.
   if (vAmpl.size()) {
      sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size()));
      sumwf->fvPulse[0]->fEUncert = 0.3; // FIXME: amplitude uncertainty correct?
      sumwf->fvPulse[1]->fEUncert = 0.3; // FIXME: amplitude uncertainty correct?
      auto itr = vAmpl.begin();
      Double_t tgamma[2] = {};

      if (vAmpl.size() >= 2) {
         tgamma[0] = sumwf->fSumWaveform->GetTimeAt(itr->second) - 10 * MEG::nanosecond;
         itr++;
         tgamma[1] = sumwf->fSumWaveform->GetTimeAt(itr->second) - 10 * MEG::nanosecond;
      } else {
         tgamma[1] = sumwf->fSumWaveform->GetTimeAt(itr->second) - 10 * MEG::nanosecond;
      }
      sumwf->fvPulse[0]->fTUncert = 4 * MEG::nanosecond;
      sumwf->fvPulse[1]->fTUncert = 4 * MEG::nanosecond;

      for (Int_t i = 0; i < 2; i++) { // MPPC and PMT
         if (tgamma[i] < -15 * MEG::nanosecond - 10 * MEG::nanosecond + 3 * MEG::nanosecond) {
            // FIXME: What are 15 ns, 10 ns, and 3 ns?
            // Tail form before Main Gamma.
            Int_t pkpnt;
            Double_t pkampl;
            sumwf->fSumWaveform->MinimumPeak(pkampl, pkpnt, sumwf->fSumWaveform->GetTimeMin() + 15 * MEG::nanosecond, -5 * MEG::nanosecond);
            sumwf->fvPulse[i]->fT = sumwf->fSumWaveform->GetTimeAt(pkpnt) - 10 * MEG::nanosecond;
            sumwf->fvPulse[i]->fTUncert = 10 * MEG::nanosecond;
         }
      }

      sumwf->fvPulse[0]->fBase = sumwf->fSumWaveform->CalculateBaseline(wfrh->GetBaselineStart(), wfrh->GetBaselineEnd());
      sumwf->fvPulse[0]->fBaseUncert = sumwf->fSumWaveform->CalculateRMS(wfrh->GetBaselineStart(), wfrh->GetBaselineEnd());
      sumwf->FitSumWF({TMath::Min(sumwf->fvPulse[0]->fT, sumwf->fvPulse[1]->fT) - 15 * MEG::nanosecond,
                       TMath::Max(sumwf->fvPulse[0]->fT, sumwf->fvPulse[1]->fT) + 30 * MEG::nanosecond}, fFitResult);
      sumwf->UpdateFitWaveforms();
      sumwf->UpdateChi2Waveform();
      sumwf->UpdateResWaveform();
   } // end if vAmpl.size() > 0
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FitPileupGammaInBaselineRegion(MEGTXECPileupUnfolding::SumWF* sumwf, const Bool_t /*fitAllRegion*/)
{
   // Search for peaks in baseline region using chi2 and residual waveforms.
   // If peaks are found, new pulses are added to fit waveform.

   if (!sumwf->fvPM.size()) {
      return;
   }

   Double_t tstart = sumwf->fSumWaveform->GetTimeMin() + 15 * MEG::nanosecond;
   Double_t tend   = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1)->GetBaselineEnd();
   if (tend <= tstart) {
      tend = tstart + 50 * MEG::nanosecond;
   }

   // Peak search and timing extraction by chi2 waveform and amplitude extraction by res waveform 
   Double_t t_pileup = sumwf->fSumWaveform->GetTimeMin() - 100 * MEG::nanosecond;
   Double_t vpeak;
   Double_t threshold = sumwf->fIsSiPM ? fNinner2Threshold : fNpmt2Threshold;
   if (!sumwf->FindResidualPulse(t_pileup, vpeak, threshold, true)) {
      return;
   }

   // Relax constraint of original pulses
   for (auto pulse : sumwf->fvPulse) {
      if (!pulse->fFixParameter) {
         pulse->fEUncert = TMath::Max(pulse->fE, pulse->fEUncert * 10);
         pulse->fTUncert = 5 * MEG::nanosecond;
      }
   }

   // Add a baseline pulse
   sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size()));
   sumwf->fvPulse.back()->fE = vpeak;
   sumwf->fvPulse.back()->fEUncert = vpeak;
   sumwf->fvPulse.back()->fT = t_pileup;

   if (sumwf->fvPulse.back()->fT < tstart) { // if pulse is earlier than waveform min, uncertainty is large.
      sumwf->fvPulse.back()->fTUncert = 40 * MEG::nanosecond;
   } else {
      sumwf->fvPulse.back()->fTUncert = 10 * MEG::nanosecond;
   }
   if (fPrint) {
      std::cout << "Pulse added T: " << sumwf->fvPulse.back()->fT << " +- " << sumwf->fvPulse.back()->fTUncert
                << " E: " << sumwf->fvPulse.back()->fE << " +- " << sumwf->fvPulse.back()->fEUncert << std::endl;
   }

   sumwf->GetFitRegion(tstart, tend);
   sumwf->SetBaselineConstraint();
   sumwf->SetMainGammaConstraint();
   sumwf->FitSumWF({tstart, tend}, fFitResult, false);
   sumwf->UpdateFitWaveforms();
   sumwf->UpdateChi2Waveform();
   sumwf->UpdateResWaveform();
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::FitPileupGammaInChargeIntegrationRegion(MEGTXECPileupUnfolding::SumWF* sumwf)
{
   // Search for peaks in charge integration region using chi2 and residual waveforms.
   // If peaks are found, new pulses are added to fit waveform.

   if (!sumwf->fvPM.size()) {
      return false;
   }

   MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);
   Double_t fitMargin = gAnalyzer->GetXECPileupUnfoldingParameters()->GetFitMargin();

   Double_t tstart = wfrh->GetChargeIntStart() + 50 * MEG::nanosecond;
   Double_t tend   = wfrh->GetChargeIntEnd() + fitMargin;
   
   // Peak search and timing extraction by chi2 waveform and amplitude extraction by res waveform 
   Double_t t_pileup = sumwf->fSumWaveform->GetTimeMin() - 100 * MEG::nanosecond;
   Double_t vpeak;
   Double_t threshold = sumwf->fIsSiPM ? fNinner2Threshold : fNpmt2Threshold;
   if (!sumwf->FindResidualPulse(t_pileup, vpeak, threshold, false)) {
      return false;
   }

   // Relax constraint of original pulses
   for (auto pulse : sumwf->fvPulse) {
      if (!pulse->fFixParameter) {
         pulse->fEUncert = TMath::Max(pulse->fE, pulse->fEUncert * 10);
         pulse->fTUncert = 5 * MEG::nanosecond;
      }
   }

   // Add a baseline pulse
   sumwf->fvPulse.push_back(new RecPulse(sumwf->fvPulse.size()));
   sumwf->fvPulse.back()->fE = vpeak;
   sumwf->fvPulse.back()->fEUncert = vpeak;
   sumwf->fvPulse.back()->fT = t_pileup;

   if (sumwf->fvPulse.back()->fT < tstart) { // if pulse is earlier than waveform min, uncertainty is large.
      sumwf->fvPulse.back()->fTUncert = 40 * MEG::nanosecond;
   } else {
      sumwf->fvPulse.back()->fTUncert = 10 * MEG::nanosecond;
   }
   if (fPrint) {
      std::cout << "Pulse added T: " << sumwf->fvPulse.back()->fT << " +- " << sumwf->fvPulse.back()->fTUncert
                << " E: " << sumwf->fvPulse.back()->fE << " +- " << sumwf->fvPulse.back()->fEUncert << std::endl;
   }

   sumwf->GetFitRegion(tstart, tend);
   sumwf->SetBaselineConstraint();
   sumwf->SetMainGammaConstraint();
   sumwf->FitSumWF({tstart, tend}, fFitResult, false);
   sumwf->UpdateFitWaveforms();
   sumwf->UpdateChi2Waveform();
   sumwf->UpdateResWaveform();

   return true;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SimulFitAndUnfold()
{
   // Unfolding method with simultaneous fit.

   auto pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();
   Bool_t reFit = kTRUE;

   if (pParameters->GetReferenceSwitch() == 0) {
      Report(R_WARNING, "Simultaneous fit requires seed pulse inputs. Turn on ReferenceSwitch.");
      return;
   }

   Bool_t fixParam(kFALSE);
   if (FillAPulse(kTRUE)) {
      fixParam = kTRUE;
      reFit = kFALSE;
   }

   MEGXECWFRunHeader* wfrh;

   // Get seed pulses and assign their IDs.
   if (!fixParam) {
      for (auto sumwf : fvTotalSumWF) {

         if (!sumwf->fvPM.size()) {
            return;
         }

         switch (pParameters->GetReferenceSwitch() / kInputSeed % 10) {
         case kConstantWindow:
            GetSeed(sumwf, &fvDiffGamma,    kDiffGamma);
            GetSeed(sumwf, &fvDeconvGamma,  kDeconvGamma);
            GetSeed(sumwf, &fvFADCGamma,    kFADCGamma);
            GetSeed(sumwf, &fvClusterGamma, kClusterGamma);
            break;

         case kOptimalSeedInput:
         default:
            GetSeedFromDiff(sumwf, &fvDiffGamma);
            GetSeedFromFADC(sumwf, &fvFADCGamma);
            GetSeedFromCluster(sumwf, &fvClusterGamma);
            break;
         }

      } // end of sumwf loop

      if (FillAPulse(kFALSE)) reFit = kFALSE; // Fill a pulse based on detected pulses
   }

   AssignSeedPulseIndex();
   if (fPrint) {
      for (auto sumwf : fvTotalSumWF) {
         sumwf->PrintPulse();
      }
   }

   Double_t maxpulsetime = fvTotalSumWF[TemplateWF::kPMT]->fSumWaveform->GetTimeMin();
   for (auto pulse : fvTotalSumWF[TemplateWF::kPMT]->fvPulse) {
      if (pulse->fT > maxpulsetime) {
         maxpulsetime = pulse->fT;
      }
   }

   // Set baseline constraint
   for (auto sumwf : fvTotalSumWF) {
      sumwf->SetBaselineConstraint(kFALSE);
   }

   wfrh = gAnalyzer->GetXECWFRunHeaderAt(TemplateWF::kPMT);
   Double_t fitstart = TMath::Max(fvTotalSumWF[TemplateWF::kSiPM]->fSumWaveform->GetTimeMin(),
                                  fvTotalSumWF[TemplateWF::kPMT] ->fSumWaveform->GetTimeMin());
   Double_t fitend   = TMath::Min(fvTotalSumWF[TemplateWF::kPMT]->fSumWaveform->GetTimeMax(),
                                  maxpulsetime + wfrh->GetChargeIntEnd() + pParameters->GetFitMargin());
   SimultaneousFit({fitstart, fitend}, fFitResult);

   UpdateChi2Waveform();
   for (auto sumwf : fvTotalSumWF) {
      sumwf->UpdateFitWaveforms();
      sumwf->UpdateResWaveform();
      sumwf->CheckConversion();
   }

   // Check convergence
   fgFCN = GetChi2();
   if (fPrint) {
      std::cout << "fgFCN " << fgFCN << std::endl;
   }

   // Re-fit
   if (reFit && fgFCN > pParameters->GetChi2Threshold()) {
      // Peak search in residual waveform in baseline region.
      // If peak over threshold is found, GetSeedFromResidual returns kTRUE with new pulse filled in fvPulse.
      if (fgFCN > pParameters->GetChi2Threshold() && GetSeedFromResidual(kTRUE)) {
         SimultaneousFit({fitstart, fitend}, fFitResult);

         UpdateChi2Waveform();
         for (auto sumwf : fvTotalSumWF) {
            sumwf->UpdateFitWaveforms();
            sumwf->UpdateResWaveform();
            sumwf->CheckConversion();
         }
         fgFCN = GetChi2();
         if (fPrint) {
            std::cout << "Baseline residual refit: fgFCN " << fgFCN << std::endl;
         }
      }

      // Post-timing peak search in residual waveform.
      // If peak over threshold is found, GetSeedFromResidual returns kTRUE with new pulse filled in fvPulse.
      if (fgFCN > pParameters->GetChi2Threshold() && GetSeedFromResidual(kFALSE)) {
         SimultaneousFit({fitstart, fitend}, fFitResult);

         UpdateChi2Waveform();
         for (auto sumwf : fvTotalSumWF) {
            sumwf->UpdateFitWaveforms();
            sumwf->UpdateResWaveform();
            sumwf->CheckConversion();
         }
         fgFCN = GetChi2();
         if (fPrint) {
            std::cout << "Post-timing residual refit: fgFCN " << fgFCN << std::endl;
         }
      }


      // Peak search in chi2 waveform.
      // If peak over threshold is found, GetSeedFromChi2 returns kTRUE with new pulse filled in fvPulse.
      if (fgFCN > pParameters->GetChi2Threshold() && GetSeedFromChi2()) {

         SimultaneousFit({fitstart, fitend}, fFitResult);

         UpdateChi2Waveform();
         for (auto sumwf : fvTotalSumWF) {
            sumwf->UpdateFitWaveforms();
            sumwf->UpdateResWaveform();
            sumwf->CheckConversion();
         }
         fgFCN = GetChi2();
         if (fPrint) {
            std::cout << "Chi2 refit: fgFCN " << fgFCN << std::endl;
         }
      }
   } // end of re-fit

   // Remove invalid pulses
   while (RemoveInvalidPulses()) {
      SimultaneousFit({fitstart, fitend}, fFitResult);

      UpdateChi2Waveform();
      for (auto sumwf : fvTotalSumWF) {
         sumwf->UpdateFitWaveforms();
         sumwf->UpdateResWaveform();
         sumwf->CheckConversion();
      }

      // Check convergence
      fgFCN = GetChi2();
      if (fPrint) {
         std::cout << "Invalid pulse removal: fgFCN " << fgFCN << std::endl;
      }
   }

   // Sort pulses so that main pulse is first.
   if (!fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[0]->fIsMain) {
      for (Int_t iPulse = 0; iPulse < static_cast<Int_t>(fvTotalSumWF[TemplateWF::kSiPM]->fvPulse.size()); ++iPulse) {
         if (fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[iPulse]->fIsMain) {
            std::swap(fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[0], fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[iPulse]);
            std::swap(fvTotalSumWF[TemplateWF::kPMT]->fvPulse[0],  fvTotalSumWF[TemplateWF::kPMT]->fvPulse[iPulse]);
            break;
         }
      }
   }

}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SimultaneousFit(const std::vector<Double_t>& FitRange, const Bool_t kPrint)
{
   // Simultaneous fitting method.
   // Initial parameters for fitting should be given by fvPulse.
   // Step size is given by uncert/5.
   // Limits are given by +/- 5*uncert.
   // Results will be over written also on fvPulse.

   if (fvTotalSumWF.size() < 2) {
      Report(R_WARNING, Form("Size of fvTotalSumWF is %d. Skip simultaneous fit.",
                             static_cast<Int_t>(fvTotalSumWF.size())));
      return;
   }

   auto pmtwf = fvTotalSumWF[TemplateWF::kPMT];
   const Int_t nPulse = pmtwf->fvPulse.size(); // Should be the same number as MPPC
   Int_t nPar = 3 + 6 * nPulse;
   const Int_t startpnt = pmtwf->fSumWaveform->FindPoint(FitRange[0]) + 1;
   const Int_t endpnt   = pmtwf->fSumWaveform->FindPoint(FitRange[1]) + 1;
   const Double_t kTimeMPPCMinusPMT = gAnalyzer->GetXECPileupUnfoldingParameters()->GetMPPCMinusPMT();

   // Init Minuit.
   TVirtualFitter::SetDefaultFitter("Minuit");
   Double_t arglist[10];
   Int_t    ierflg = 0;
   Double_t edm, errdef, fcn;
   Int_t    nvpar, nparx, icstat;
   if (fgMinuit && fgMinuit->GetNumPars() != nPar) {
      delete fgMinuit;
      fgMinuit = 0;
   }
   if (!fgMinuit) {
      fgMinuit = new TMinuit(nPar);
      fgMinuit->SetFCN(SimulFCN);
      if (!kPrint) {
         fgMinuit->SetPrintLevel(-1);
      }
      fgMinuit->mnexcm("SET NOW", arglist, 0, ierflg);
      arglist[0] = 1;
      fgMinuit->mnexcm("SET ERR", arglist, 1, ierflg); // UP = 1 : normal chisquare fit
      arglist[0] = 1;
      fgMinuit->mnexcm("SET STR", arglist, 1, ierflg); // normal
   }

   // Set Parameters.
   fgMinuit->mnparm(0, "RangeUL", startpnt, 0, startpnt, startpnt, ierflg);
   fgMinuit->mnparm(1, "RangeLL", endpnt, 0, endpnt, endpnt, ierflg);
   fgMinuit->mnparm(2, "NPulse", nPulse, 0, nPulse, nPulse, ierflg);
   fgMinuit->FixParameter(0);
   fgMinuit->FixParameter(1);
   fgMinuit->FixParameter(2);
   for (auto mppcPulse : fvTotalSumWF[TemplateWF::kSiPM]->fvPulse) {
      for (Int_t iPulse = 0; iPulse < nPulse; iPulse++) {
         auto pmtPulse = fvTotalSumWF[TemplateWF::kPMT]->fvPulse[iPulse];
         if (mppcPulse->fPulseIndex == pmtPulse->fPulseIndex) {
            //if (pmtPulse->fPulseIndex != iPulse) {
            //   Report(R_ERROR, "Pulse index in MPPC differs from that in PMT! Modify source code.");
            //}
            fgMinuit->mnparm(3 + mppcPulse->fPulseIndex * 6, "MPPC Scale", mppcPulse->fE,
                             mppcPulse->fEUncert / 5.,
                             TMath::Max(0., mppcPulse->fE - 5 * mppcPulse->fEUncert),
                             mppcPulse->fE + 5 * mppcPulse->fEUncert, ierflg);
            if (GetSP()->GetSimultaneousFit()->GetFixTimeDifferenceFlag()) {
               fgMinuit->mnparm(4 + mppcPulse->fPulseIndex * 6, "MPPC Time difference", kTimeMPPCMinusPMT, 0,
                                kTimeMPPCMinusPMT, kTimeMPPCMinusPMT, ierflg);
            } else {
               fgMinuit->mnparm(4 + mppcPulse->fPulseIndex * 6, "MPPC Time difference", mppcPulse->fT - pmtPulse->fT,
                                mppcPulse->fTUncert / 5.,
                                mppcPulse->fT - pmtPulse->fT - 5 * pmtPulse->fTUncert,
                                mppcPulse->fT - pmtPulse->fT + 5 * pmtPulse->fTUncert, ierflg);
            }
            fgMinuit->mnparm(5 + mppcPulse->fPulseIndex * 6, "MPPC Baseline", mppcPulse->fBase,
                             mppcPulse->fBaseUncert / 5.,
                             mppcPulse->fBase - 5 * mppcPulse->fBaseUncert,
                             mppcPulse->fBase + 5 * mppcPulse->fBaseUncert, ierflg);
            fgMinuit->mnparm(6 + mppcPulse->fPulseIndex * 6, "PMT Scale", pmtPulse->fE,
                             pmtPulse->fEUncert / 5.,
                             TMath::Max(0., pmtPulse->fE - 5 * pmtPulse->fEUncert),
                             pmtPulse->fE + 5 * pmtPulse->fEUncert, ierflg);
            fgMinuit->mnparm(7 + mppcPulse->fPulseIndex * 6, "PMT Timing", pmtPulse->fT,
                             pmtPulse->fTUncert / 5.,
                             pmtPulse->fT - 5 * pmtPulse->fTUncert,
                             pmtPulse->fT + 5 * pmtPulse->fTUncert, ierflg);
            fgMinuit->mnparm(8 + mppcPulse->fPulseIndex * 6, "PMT Baseline", pmtPulse->fBase,
                             pmtPulse->fBaseUncert / 5.,
                             pmtPulse->fBase - 5 * pmtPulse->fBaseUncert,
                             pmtPulse->fBase + 5 * pmtPulse->fBaseUncert, ierflg);
            break;
         }
      }
      if (GetSP()->GetSimultaneousFit()->GetFixTimeDifferenceFlag()) {
         fgMinuit->FixParameter(4 + mppcPulse->fPulseIndex * 6);
      }
      if (mppcPulse->fPulseIndex != 0) {
         fgMinuit->FixParameter(5 + mppcPulse->fPulseIndex * 6);
         fgMinuit->FixParameter(8 + mppcPulse->fPulseIndex * 6);
      }
   }

   // execute MIGRAD minimization
   arglist[0] = 2000;
   arglist[1] = 0.1;
   fgMinuit->mnexcm("MIGRAD", arglist, 2, ierflg);
   fgMinuit->mnstat(fcn, edm, errdef, nvpar, nparx, icstat);
   if (kPrint) {
      fgMinuit->mnprin(3, fcn);
   }
   if (kPrint) {
      printf("%d Gamma Fit. Chi2 NDF : %.1lf.\n", nPulse, fcn);
   }
   fgFCN = fcn;

   // Fill result.
   for (Int_t iPulse = 0; iPulse < nPulse; iPulse++) {
      auto mppcPulse = fvTotalSumWF[TemplateWF::kSiPM]->fvPulse[iPulse];
      auto pmtPulse  = fvTotalSumWF[TemplateWF::kPMT] ->fvPulse[iPulse];
      mppcPulse->fPulseIndex = iPulse;
      pmtPulse->fPulseIndex = iPulse;
      fgMinuit->GetParameter(3 + iPulse * 6, mppcPulse->fE,    mppcPulse->fEUncert);
      fgMinuit->GetParameter(4 + iPulse * 6, mppcPulse->fT,    mppcPulse->fTUncert);
      fgMinuit->GetParameter(5 + iPulse * 6, mppcPulse->fBase, mppcPulse->fBaseUncert);
      fgMinuit->GetParameter(6 + iPulse * 6, pmtPulse->fE,     pmtPulse->fEUncert);
      fgMinuit->GetParameter(7 + iPulse * 6, pmtPulse->fT,     pmtPulse->fTUncert);
      fgMinuit->GetParameter(8 + iPulse * 6, pmtPulse->fBase,  pmtPulse->fBaseUncert);
      mppcPulse->fT += pmtPulse->fT;
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::ReFitAndUnfold(MEGTXECPileupUnfolding::SumWF* sumwf)
{
   // Refit method.
   // Set constraints again and fit again.

   if (fPrint) {
      std::cout << "Before refit: " << std::endl;
      sumwf->PrintPulse();
   }

   Double_t fitstart;
   Double_t fitend;
   sumwf->GetFitRegion(fitstart, fitend);
   sumwf->SetBaselineConstraint();
   sumwf->SetMainGammaConstraint();
   sumwf->FitSumWF({fitstart, fitend}, fFitResult);

   sumwf->UpdateFitWaveforms();
   sumwf->UpdateChi2Waveform();
   sumwf->UpdateResWaveform();

   sumwf->CheckConversion();
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeDiffWF(Short_t sw)
{
   // Pulses are detected using PMT differential waveform.
   // Waveform sums are analyzed to extract seed pulse timing and size based on the pulses' timing.
   // Switch introduction: 1: method used before 2021, 2: fvT is PMT diff pktime and fvE is amplitude.

   Double_t tstart, tend;
   Double_t baseline, charge;
   Double_t cfamplitude, cftime, pktime, diffpktime, pkampl, minpkampl;
   Int_t    pkpoint;
   MEGXECWFRunHeader *wfrh;
   std::vector<std::vector<Double_t> > relativeAnaRegion = // relative analysis region from PMT diff peak time
         {{-20 * MEG::nanosecond, 45 * MEG::nanosecond},  // MPPC
          {-20 * MEG::nanosecond, 15 * MEG::nanosecond}}; // PMT
   std::vector<SeedGamma*> vGamma;
   Double_t diffMargin = 200 * MEG::nanosecond; // consistent with Satoru's development

   // Diff parameters
   auto* pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();
   pParameters->SetDiffPeakTimeSize(0);
   pParameters->SetDiffPeakAmplitudeSize(0);
   pParameters->SetDiffSeedPeakTimeSize(0);
   pParameters->SetDiffSeedBaselineSize(0);
   pParameters->SetDiffSeedPeakHeightSize(0);

   // Pulse search with PMT differential waveform
   auto pmtsumwf = fvTotalSumWF[TemplateWF::kPMT];
   wfrh = gAnalyzer->GetXECWFRunHeaderAt(TemplateWF::kPMT);
   std::map<Double_t, Int_t, std::less<Double_t>> vPeak; // amplitude, peak point
   tstart = pmtsumwf->fSumWaveform->GetTimeMin() + 15 * MEG::nanosecond;
   tend = TMath::Min(wfrh->GetChargeIntEnd() + diffMargin,
                     pmtsumwf->fSumWaveform->GetTimeMax() - 50 * MEG::nanosecond);
   pmtsumwf->PeakSearchInDiff({tstart, tend}, vPeak, pParameters->GetDiffThreshold());
   pParameters->SetDiffPeakTimeSize(vPeak.size());
   pParameters->SetDiffPeakAmplitudeSize(vPeak.size());
   pParameters->SetDiffSeedPeakTimeSize(vPeak.size() * 2);
   pParameters->SetDiffSeedBaselineSize(vPeak.size() * 2);
   pParameters->SetDiffSeedPeakHeightSize(vPeak.size() * 2);

   for (auto peak : vPeak) {
      vGamma.push_back(new SeedGamma(vGamma.size()));
      vGamma.back()->fSumWFIndex = pmtsumwf->fIndex;
      vGamma.back()->fvE.resize(2); // SiPM and PMT
      vGamma.back()->fvT.resize(2);

      diffpktime = pmtsumwf->fDiffWaveform->GetTimeAt(peak.second);

      pParameters->SetDiffPeakTimeAt(vGamma.size() - 1, diffpktime);
      pParameters->SetDiffPeakAmplitudeAt(vGamma.size() - 1, peak.first);

      switch (sw) { // Time and signal scale calculation switch
      case 1:
         pmtsumwf->fSumWaveform->MinimumPeak(pkampl, pkpoint,
                                             diffpktime - 5 * MEG::nanosecond,
                                             diffpktime + 15 * MEG::nanosecond);
         pktime = pmtsumwf->fSumWaveform->GetTimeAt(pkpoint);
         baseline = 0;
         // Timing extraction
         cfamplitude = (peak.first - baseline) * kConstantFraction + baseline;
         cftime = pmtsumwf->fSumWaveform->ConstantFraction(cfamplitude,
                                                           peak.first * 0.9,
                                                           pktime - 50 * MEG::nanosecond,
                                                           pktime + 20 * MEG::nanosecond,
                                                           -1, "CUBIC");
         if (TMath::Abs(cftime - pktime) > 30 * MEG::nanosecond) {
            cftime = pktime - 15 * MEG::nanosecond;
         }
         for (auto sumwf : fvTotalSumWF) {
            if (sumwf->fIndex > 1) { // if not MPPC and PMT total waveform sum
               continue;
            }
            vGamma.back()->fvT[sumwf->fIndex] = cftime + sumwf->fRefTime;
         }

         // Charge integration
         tstart = TMath::Max(pktime + wfrh->GetChargeIntStart(),
                             pmtsumwf->fSumWaveform->GetTimeMin() + 15 * MEG::nanosecond);
         tend = pmtsumwf->fSumWaveform->GetTimeAt(peak.second) + wfrh->GetChargeIntEnd();
         // Check the neighboring pulses
         for (auto peak2 : vPeak) {
            if (peak.second == peak2.second) {
               continue;
            }
            Double_t pktime_tmp = pmtsumwf->fSumWaveform->GetTimeAt(peak2.second);
            if (pktime_tmp < pktime) { // earlier
               tstart = TMath::Max(tstart, pktime_tmp + wfrh->GetChargeIntEnd() / 2);
            } else {
               tend = TMath::Min(tend, pktime_tmp + wfrh->GetChargeIntStart() / 2);
            }
         }
         for (auto sumwf : fvTotalSumWF) {
            if (sumwf->fIndex > 1) { // if not MPPC and PMT total waveform sum
               continue;
            }
            charge = sumwf->fSumWaveform->ChargeIntegration(tstart, tend, baseline);
            vGamma.back()->fvE[sumwf->fIndex] = -charge;
         }

         break;

      case 2:
      default:
         for (auto sumwf : fvTotalSumWF) {
            if (sumwf->fIndex > 1) { // if not MPPC and PMT total waveform sum
               continue;
            }
            wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIndex);

            // Peak extraction
            sumwf->fSumWaveform->MinimumPeak(pkampl, pkpoint,
                                             diffpktime + relativeAnaRegion[sumwf->fIndex][0],
                                             diffpktime + relativeAnaRegion[sumwf->fIndex][1]);
            pktime = sumwf->fSumWaveform->GetTimeAt(pkpoint);
            sumwf->fSumWaveform->MaximumPeak(minpkampl, pkpoint,
                                             diffpktime + relativeAnaRegion[sumwf->fIndex][0],
                                             diffpktime + relativeAnaRegion[sumwf->fIndex][1]);

            pParameters->SetDiffSeedBaselineAt((vGamma.size() - 1) * 2 + sumwf->fIndex,
                                               minpkampl);

            vGamma.back()->fvE[sumwf->fIndex] = -(pkampl - minpkampl);
            // 5 ns is typical time difference between diff pktime and 5% cftime
            vGamma.back()->fvT[sumwf->fIndex] = diffpktime + sumwf->fRefTime - 5 * MEG::nanosecond;

         } // end of sumwf loop

         // Flag invalid if amplitude less than threshold
         if (vGamma.back()->fvE[TemplateWF::kSiPM] < pParameters->GetNinner2Threshold() &&
             vGamma.back()->fvE[TemplateWF::kPMT]  < pParameters->GetNpmt2Threshold()) {
            vGamma.back()->fInvalid = kTRUE;
         }
         break;
      } // end of switch

      // Fill parameters for monitor
      for (Int_t idx = 0; idx < 2; ++idx) { // MPPC and PMT
         pParameters->SetDiffSeedPeakTimeAt((vGamma.size() - 1) * 2 + idx,
                                            vGamma.back()->fvT[idx] - fvTotalSumWF[idx]->fRefTime);
         pParameters->SetDiffSeedPeakHeightAt((vGamma.size() - 1) * 2 + idx,
                                              vGamma.back()->fvE[idx]);
      }
   } // end of peak loop

   for (auto gamma : vGamma) {
      if (!gamma->fInvalid) {
         fvDiffGamma.push_back(gamma);
      } else {
         delete gamma;
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeDeconvWF()
{
   const Float_t kThresholdFrac = 0.1;

   Double_t tstart, tend;
   Double_t baseline, charge;
   Double_t cfamplitude, cftime, pktime;
   std::vector<SeedGamma*> vGamma;
   for (auto sumwf : fvTotalSumWF) {
      if (sumwf->fType != fvTemplateType[TemplateWF::kPMT]) {
         continue;   //only all PMT
      }

      MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);
      sumwf->Deconvolute(sumwf->fSumWaveform,
                         GetSP()->GetDeconvolution()->GetConvolutionMethod(),
                         GetSP()->GetDeconvolution()->GetPulseWidth() * nanosecond,
                         fDrawResult);
      sumwf->DeconvPeakSearch();

      for (auto peak : sumwf->fDeconvWF->fvPeak) {
         if (peak.first < kThresholdFrac * sumwf->fDeconvWF->fvPeak[0].first) {
            continue;
         }
         vGamma.push_back(new SeedGamma((Int_t)vGamma.size()));
         vGamma.back()->fSumWFIndex = sumwf->fIndex;
         vGamma.back()->fvE.resize(2);
         vGamma.back()->fvT.resize(2);

         pktime = sumwf->fSumWaveform->GetTimeAt(peak.second);

         /* ------------- Baseline Calculation----------------*/
         tstart = TMath::Max(sumwf->fSumWaveform->GetTimeAt(peak.second) + wfrh->GetBaselineStart(),
                             sumwf->fSumWaveform->GetTimeMin() + 15 * nanosecond);
         tend = sumwf->fSumWaveform->GetTimeAt(peak.second) + wfrh->GetBaselineEnd();
         baseline = sumwf->fSumWaveform->CalculateBaseline(tstart, tend);

         /* ------------- Charge integration----------------*/
         tstart = TMath::Max(sumwf->fSumWaveform->GetTimeAt(peak.second) + wfrh->GetChargeIntStart(),
                             sumwf->fSumWaveform->GetTimeMin() + 15 * nanosecond);
         tend = sumwf->fSumWaveform->GetTimeAt(peak.second) + wfrh->GetChargeIntEnd();
         //check the neighbor pulses
         for (auto peak2 : sumwf->fDeconvWF->fvPeak) {
            if (peak.second == peak2.second) {
               continue;
            }
            Double_t pktime_tmp = sumwf->fSumWaveform->GetTimeAt(peak2.second);
            if (pktime_tmp < pktime) { // earlier
               tstart = TMath::Max(tstart, pktime_tmp + wfrh->GetChargeIntEnd() / 2);
            } else {
               tend = TMath::Min(tend, pktime_tmp + wfrh->GetChargeIntStart() / 2);
            }
         }
         charge = sumwf->fSumWaveform->ChargeIntegration(tstart, tend, baseline);
         vGamma.back()->fvE[sumwf->fIsSiPM ? 0 : 1] = -charge;
         auto sumwf2 = FindSumWF(fvTemplateType[TemplateWF::kSiPM]);
         charge = sumwf2->fSumWaveform->ChargeIntegration(tstart, tend, baseline);
         vGamma.back()->fvE[sumwf->fIsSiPM ? 1 : 0] = -charge;

         /* ------------- Timing extraction----------------*/
         cfamplitude = (peak.first - baseline) * kConstantFraction + baseline;
         cftime = sumwf->fSumWaveform->ConstantFraction(
                     cfamplitude,
                     peak.first * 0.9,
                     sumwf->fSumWaveform->GetTimeAt(peak.second) - 50 * nanosecond,
                     sumwf->fSumWaveform->GetTimeAt(peak.second) + 20 * nanosecond,
                     -1, "CUBIC");
         if (TMath::Abs(cftime - pktime) > 100 * nanosecond) {
            cftime = pktime - 15 * nanosecond;
         }
         vGamma.back()->fvT[sumwf->fIsSiPM ? 0 : 1] = cftime + sumwf->fRefTime;
         vGamma.back()->fvT[sumwf->fIsSiPM ? 1 : 0] = cftime + sumwf->fRefTime; // use only PMT
      }
   }

   for (auto gamma : vGamma) {
      if (!gamma->fInvalid) {
         fvDeconvGamma.push_back(gamma);
      } else {
         delete gamma;
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::ReadPileupClusteringResult()
{
   // Read clustering results analyzed in PileupClustering.

   const Int_t nGamma = gAnalyzer->GetXECPileupClusteringResultSize();
   if (!nGamma && fPrint) {
      Report(R_WARNING, "XECPileupClusteringResult is not filled.");
      return;
   }

   MEGXECPileupClusteringResult* pXECPLCL;
   for (Int_t iGamma = 0; iGamma < nGamma; ++iGamma) {
      pXECPLCL = gAnalyzer->GetXECPileupClusteringResultAt(iGamma);
      fvClusterGamma.push_back(new ClusterGamma(iGamma));
      fvClusterGamma.back()->fUVW[0] = pXECPLCL->Getupeak();
      fvClusterGamma.back()->fUVW[1] = pXECPLCL->Getvpeak();
      fvClusterGamma.back()->fUVW[2] = pXECPLCL->Getwpeak();
      fvClusterGamma.back()->fT      = pXECPLCL->Gettpeak();
      if (pXECPLCL->Gettpeakpm() > -1 && gAnalyzer->GetXECTimeFitResultSize()) {
         auto pTimeFit = gAnalyzer->GetXECTimeFitResultAt(0);
         if (pTimeFit->GettdelaySize()) {
            fvClusterGamma.back()->fT -= pTimeFit->GettdelayAt(pXECPLCL->Gettpeakpm());
         }
      }
      fvClusterGamma.back()->fE      = pXECPLCL->Getepeak();
      fvClusterGamma.back()->fMode   = pXECPLCL->Getmode(); // primary
      fvClusterGamma.back()->fvMode.push_back(pXECPLCL->Getmode());
      fvClusterGamma.back()->fClusterid = pXECPLCL->Getclusterid(); // primary
      fvClusterGamma.back()->fClusteridMap[pXECPLCL->Getmode()].push_back(pXECPLCL->Getclusterid());
      fvClusterGamma.back()->fInverted = pXECPLCL->Getinverted();
      fvClusterGamma.back()->fIsMainInCluster = kTRUE;
      fvClusterGamma.back()->fStatus = pXECPLCL->Getstat();
      for (Int_t iPM = 0; iPM < pXECPLCL->GetpmlistSize(); iPM++) {
         fvClusterGamma.back()->fvPM.push_back(pXECPLCL->GetpmlistAt(iPM));
      }

      // SumWaveform Object
      // SiPM
      fvClusterSumWF.push_back(new SumWF(SumWF::kClusterSumWF, static_cast<Int_t>(fvClusterSumWF.size()),
                                         kTRUE, fvTemplateType[TemplateWF::kSiPM]));
      for (Int_t iPM = 0; iPM < pXECPLCL->GetpmlistSize(); iPM++) {
         if (gAnalyzer->GetXECPMRunHeaderAt(pXECPLCL->GetpmlistAt(iPM))->GetIsSiPM()) {
            fvClusterSumWF.back()->fvPM.push_back(pXECPLCL->GetpmlistAt(iPM));
         }
      }
      fvClusterSumWF.back()->fRefTime    = fvClusterGamma.back()->fT;
      fvClusterSumWF.back()->fTemplateWF = FindTemplateWF(TemplateWF::kSiPM);
      fvClusterGamma.back()->fvSumWF.push_back(fvClusterSumWF.back());

      // PMT
      fvClusterSumWF.push_back(new SumWF(SumWF::kClusterSumWF, static_cast<Int_t>(fvClusterSumWF.size()),
                                         kFALSE, fvTemplateType[TemplateWF::kPMT]));
      for (Int_t iPM = 0; iPM < pXECPLCL->GetpmlistSize(); iPM++) {
         if (!gAnalyzer->GetXECPMRunHeaderAt(pXECPLCL->GetpmlistAt(iPM))->GetIsSiPM()) {
            fvClusterSumWF.back()->fvPM.push_back(pXECPLCL->GetpmlistAt(iPM));
         }
      }
      fvClusterSumWF.back()->fRefTime    = fvClusterGamma.back()->fT;
      fvClusterSumWF.back()->fTemplateWF = FindTemplateWF(TemplateWF::kPMT);
      fvClusterGamma.back()->fvSumWF.push_back(fvClusterSumWF.back());

      fvClusterGamma.back()->fvT.resize(fvClusterGamma.back()->fvSumWF.size());
      fvClusterGamma.back()->fvE.resize(fvClusterGamma.back()->fvSumWF.size());
      for (Int_t iSumWF = 0; iSumWF < static_cast<Int_t>(fvClusterGamma.back()->fvSumWF.size()); iSumWF++) {
         if (fvClusterGamma.back()->fvSumWF[iSumWF]->fvPM.size()) {
            fvClusterGamma.back()->fvT[iSumWF] = fvClusterGamma.back()->fT;
            fvClusterGamma.back()->fvE[iSumWF] = 0;
         } else {
            fvClusterGamma.back()->fvT[iSumWF] = 1e10 * MEG::second;
            fvClusterGamma.back()->fvE[iSumWF] = 0;
         }
      }

   } // end of PLCL result loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FindMainGammaCluster(Short_t sw)
{
   // Find single main gamma cluster.
   // Criteria:
   //  - Distance from main gamma position reconstructed by PosLocalFit is the shortest,
   //  - Timing is close to reference time in case of sw = 1 or
   //     main gamma time reconstructed by TimeFit in case of sw = 2.
   //  - Cluster in inner face.
   //  - Energy from PileupClustering.

   if (!fvClusterGamma.size()) {
      return;
   }

   Double_t uvw[3];
   gAnalyzer->GetXECPosLocalFitResultAt(0)->GetuvwCopy(3, uvw);
   Double_t time;
   switch (sw) {
   case 1:
      time = fgRefTime;
      break;
   case 2:
   default:
      time = gAnalyzer->GetXECTimeFitResultAt(0)->Gettime();
      break;
   }

   Int_t iMainGammaCluster = -1;
   Double_t minDistance = 1000 * MEG::centimeter;
   for (Int_t icluster = 0; icluster < static_cast<Int_t>(fvClusterGamma.size()); icluster++) {
      Double_t distance = TMath::Sqrt(TMath::Power(uvw[0] - fvClusterGamma[icluster]->fUVW[0], 2) +
                                      TMath::Power(uvw[1] - fvClusterGamma[icluster]->fUVW[1], 2));
      if (distance < minDistance // Close to main gamma position
          && TMath::Abs(fvClusterGamma[icluster]->fT - time) < 30 * MEG::nanosecond // Close to reference timing
          && fvClusterGamma[icluster]->fMode == ClusterGamma::kLDInner // Inner face
          && fvClusterGamma[icluster]->fE > 5.e-04 // Reasonable energy
          ) {
         minDistance = distance;
         iMainGammaCluster = icluster;
      }
   } // end of cluster gamma loop

   if (iMainGammaCluster > -1) {
      fvClusterGamma[iMainGammaCluster]->fIsMain = kTRUE;
   }
   //if (iMainGammaCluster < 0) {
   //   // If main gamma cluster is not found, zero-th element.
   //   iMainGammaCluster = 0;
   //}
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::InvalidateUnusedClusterGamma(Short_t sw)
{
   // Invalidate unused ClusterGamma.
   // Switch:
   //   - 1: Spatial distribution in inner.
   //   - 2: Spatial distributions in inner and outer.

   if (!fvClusterGamma.size()) {
      return;
   }

   for (auto clgamma : fvClusterGamma) {
      switch (sw) {
      case 1:
         if (!clgamma->fIsMain && clgamma->fMode != ClusterGamma::kLDInner) {
            clgamma->fInvalid = kTRUE;
         }
         break;
      case 2:
      default:
         if (clgamma->fMode == ClusterGamma::kTD) { // if time distribution
            clgamma->fInvalid = kTRUE;
         }
         break;
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::SetClusterWaveformsPointer()
{
   // Set pointer to cluster waveforms for monitor

   auto pPlot = gAnalyzer->GetXECPileupMonitorPlots();
   Int_t nInnerSumWF(0), nOuterSumWF(0);

   // Count number of clusters;
   for (auto gamma : fvClusterGamma) {
      if (gamma->fMode == ClusterGamma::kLDInner) { // inner
         nInnerSumWF++;
      } else if (gamma->fMode == ClusterGamma::kLDOuter) { // outer
         nOuterSumWF++;
      }
   }
   pPlot->SetInnerClusterWaveformSize(nInnerSumWF);
   pPlot->SetOuterClusterWaveformSize(nOuterSumWF);
   pPlot->SetInnerCLWFRefTimeSize(nInnerSumWF);
   pPlot->SetOuterCLWFRefTimeSize(nOuterSumWF);

   Int_t    iInnerSumWF(0), iOuterSumWF(0);
   Double_t reftime;
   for (auto gamma : fvClusterGamma) {
      if (gamma->fMode == ClusterGamma::kLDInner) { // inner
         gamma->fvSumWF[TemplateWF::kSiPM]->fSumWaveform = pPlot->GetInnerClusterWaveformAt(iInnerSumWF);
         reftime = gamma->fvSumWF[TemplateWF::kSiPM]->fRefTime;
         if (reftime > 0) {
            reftime = fgRefTime;
         }
         pPlot->SetInnerCLWFRefTimeAt(iInnerSumWF, reftime);
         iInnerSumWF++;
      } else if (gamma->fMode == ClusterGamma::kLDOuter) { // outer
         gamma->fvSumWF[TemplateWF::kPMT]->fSumWaveform = pPlot->GetOuterClusterWaveformAt(iOuterSumWF);
         reftime = gamma->fvSumWF[TemplateWF::kPMT]->fRefTime;
         if (reftime > 0) {
            reftime = fgRefTime;
         }
         pPlot->SetOuterCLWFRefTimeAt(iOuterSumWF, reftime);
         iOuterSumWF++;
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeClusterWF()
{
   // Clustering waveform sums are analyzed with two options to do it.
   // One is template waveform fit and the other is peak search of waveform sums.

   if (!fvClusterGamma.size()) {
      return;
   }

   switch (gAnalyzer->GetXECPileupUnfoldingParameters()->GetClusterAnalysisMethod()) {
   case kFitting:
      AnalyzeClusterWFByFitting();
      break;
   case kPeakSearch:
      AnalyzeClusterWFByPeakSearch();
      break;
   case kRefTimePeak:
   default:
      AnalyzeClusterWFPeakAroundRefTime();
      break;
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeClusterWFByFitting()
{
   // Not reviewed on December 2023 because this method is not used in 2021+2022 analysis.

   for (auto sumwf : fvClusterSumWF) {
      FitMainGamma(sumwf);
   }

   // Pileup search in cluster
   std::vector<ClusterGamma*> vClusterGamma = fvClusterGamma; // store original
   for (auto gamma : vClusterGamma) {
      if (gamma->fInvalid) {
         continue;
      }
      Int_t nGammaIni;
      Int_t iIter = 0;
      const Int_t nIter = 3;
      switch (GetSP()->GetClusterAnalysis()->GetPileupSearchMethod()) {
      case kFitting :
         for (auto sw : kvFitRegion) {
            do {
               nGammaIni = (Int_t)fvClusterGamma.size();
               FindPileupGammaByFitting(gamma, sw);
            } while (nGammaIni != (Int_t)fvClusterGamma.size() && iIter++ < nIter);
         }
         break;
      case kPeakSearch :
         do {
            nGammaIni = (Int_t)fvClusterGamma.size();
            FindPileupGammaByPeakSearch(gamma);
         } while (nGammaIni != (Int_t)fvClusterGamma.size() && iIter++ < nIter);
         break;
      default:
         break;
      }
   }

   // Update parameters
   for (auto gamma : fvClusterGamma) {
      Double_t time = 1e10;
      Double_t timeUncert = 1e10;
      for (auto sumwf : gamma->fvSumWF) {
         if (!sumwf->fvPM.size() || !sumwf->fvPulse.size()) {
            gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = 1e10 * second;
            gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = 0;
            continue;
         }
         if (timeUncert > sumwf->fvPulse[0]->fTUncert) {
            time = sumwf->fvPulse[0]->fT + sumwf->fRefTime;
            timeUncert = sumwf->fvPulse[0]->fTUncert;
         }
         gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse[0]->fT + sumwf->fRefTime;
         auto sumwf2 = FindSumWF(sumwf->fType);
         gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse[0]->fE * sumwf->fNormCharge / sumwf2->fNormCharge;
      }
      gamma->fT = time;
   }

   // Merge gammas
   MergeClusterGamma();

   // Update and Fit again with updated PM list
   for (auto gamma : fvClusterGamma) {
      if (gamma->fInvalid) {
         continue;
      }
      for (auto sumwf : gamma->fvSumWF) {
         sumwf->MakeSumWF();
         FitMainGamma(sumwf);
      }
   }

   // Update parameters
   for (auto gamma : fvClusterGamma) {
      if (gamma->fInvalid) {
         continue;
      }
      Double_t time = 1e10;
      Double_t timeUncert = 1e10;
      for (auto sumwf : gamma->fvSumWF) {
         if (!sumwf->fvPM.size() || !sumwf->fvPulse.size()) {
            continue;
         }
         if (timeUncert > sumwf->fvPulse[0]->fTUncert) {
            time = sumwf->fvPulse[0]->fT + sumwf->fRefTime;
            timeUncert = sumwf->fvPulse[0]->fTUncert;
         }
         gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse[0]->fT + sumwf->fRefTime;
         auto sumwf2 = FindSumWF(sumwf->fType);
         if (sumwf2) {
            gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse[0]->fE * sumwf->fNormCharge / sumwf2->fNormCharge;
         }
      }
      gamma->fT = time;
   }

   // Merge again based on timing. Pileup on time is also merged here.
   MergeClusterGamma(false, ClusterGamma::kTimingBasedMerge);
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeClusterWFByPeakSearch()
{
   // Not reviewed on December 2023 because this method is not used in 2021+2022 analysis.

   std::vector<ClusterGamma*> vClusterGamma = fvClusterGamma;
   for (auto gamma : vClusterGamma) {
      if (!gamma->fInverted) {
         PeakSearchInClusterGamma(gamma, true);
      } else {
         // temporary, trigger timing must be used.
         if (gamma->fT > fgRefTime - 100 * nanosecond) {
            PeakSearchInClusterGamma(gamma, true);
         } else {
            // PLCL result in baseline region
            PeakSearchInClusterGamma(gamma, true);
         }
      }
   }

   // Update parameters
   for (auto gamma : fvClusterGamma) {
      gamma->fT = TMath::Min(gamma->fvT[0], gamma->fvT[1]);
   }

   // // Merge gammas
   // MergeClusterGamma();

   // // Update and Search again with updated PM list
   // for (auto gamma : fvClusterGamma) {
   //    if (gamma->fInvalid) {
   //       continue;
   //    }
   //    for (auto sumwf : gamma->fvSumWF) {
   //       sumwf->MakeSumWF();
   //    }
   //    if (!gamma->fInverted) {
   //       PeakSearchInClusterGamma(gamma, false);
   //    } else {
   //       // temporary, trigger timing must be used.
   //       if (gamma->fT > fgRefTime - 100 * nanosecond) {
   //          PeakSearchInClusterGamma(gamma, false);
   //       } else {
   //          for (auto sumwf : gamma->fvSumWF) {
   //             for (auto pulse : sumwf->fvPulse) {
   //                delete pulse;
   //             }
   //             sumwf->fvPulse.clear();
   //             sumwf->UpdateChi2Waveform();
   //             sumwf->UpdateResWaveform();
   //             FitPileupGammaInBaselineRegion(sumwf);
   //             if ((Int_t)sumwf->fvPulse.size() > 0) {
   //                // update parameter
   //                auto sumwf2 = FindSumWF(sumwf->fType);
   //                gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse.back()->fE * sumwf->fNormCharge / sumwf2->fNormCharge;
   //                gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse.back()->fT + sumwf->fRefTime;
   //             } else {
   //                PeakSearchInClusterGamma(gamma, false);
   //             }
   //          }
   //       }
   //    }
   //    gamma->fT = TMath::Min(gamma->fvT[0], gamma->fvT[1]);
   // }

   // // Merge again based on timing. Pileup on time is also merged here.
   // MergeClusterGamma(false, ClusterGamma::kTimingBasedMerge);
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeClusterWFPeakAroundRefTime()
{
   // Calculate constant fraction time and signal height for a pulse around reference time.

   Int_t    pkpoint;
   Double_t baseline, pkampl, pktime;//, cfampl, pktime, cftime;
   //const Float_t kFraction = 0.1;
   MEGXECWFRunHeader* wfrh;
   auto* pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();

   // Count number of clusters
   Int_t nInnerCL(0), nOuterCL(0);
   for (auto gamma : fvClusterGamma) {
      if (gamma->fInvalid) {
         continue;
      }
      if (gamma->fMode == ClusterGamma::kLDInner) {
         nInnerCL++;
      } else if (gamma->fMode == ClusterGamma::kLDOuter) {
         nOuterCL++;
      }
   }
   pParameters->SetClusterSeedPeakTimeInnerSize(nInnerCL);
   pParameters->SetClusterSeedBaselineInnerSize(nInnerCL);
   pParameters->SetClusterSeedPeakHeightInnerSize(nInnerCL);
   pParameters->SetClusterSeedPeakTimeOuterSize(nOuterCL);
   pParameters->SetClusterSeedBaselineOuterSize(nOuterCL);
   pParameters->SetClusterSeedPeakHeightOuterSize(nOuterCL);

   Int_t iInnerCL(0), iOuterCL(0);
   for (auto gamma : fvClusterGamma) {
      if (gamma->fInvalid) {
         continue;
      }
      for (auto sumwf : gamma->fvSumWF) {
         if (!sumwf->fvPM.size()) {
            gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = 0;
            gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = MEGWaveform::kInvalidTime;
            //Report(R_INFO, "No PM is used. Skip.");
            continue;
         }
         wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);

         // Baseline calculation
         baseline = sumwf->fSumWaveform->CalculateBaseline(wfrh->GetBaselineStart(), wfrh->GetBaselineEnd());

         // Height calculation
         sumwf->fSumWaveform->MinimumPeak(pkampl, pkpoint, wfrh->GetChargeIntStart(), wfrh->GetChargeIntEnd());
         gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = -(pkampl - baseline);
         pktime = sumwf->fSumWaveform->GetTimeAt(pkpoint);

         // Time calculation
         // Cluster time is not updated as of August 2024.
         //cfampl = (pkampl - baseline) * kFraction + baseline;
         //cftime = sumwf->fSumWaveform->ConstantFraction(cfampl, pkampl * 0.9,
         //                                               pktime - 80 * MEG::nanosecond, pktime + 20 * MEG::nanosecond,
         //                                               -1);
         //if (cftime > sumwf->fSumWaveform->GetTimeMax()) {
         //   cftime = gamma->fT - sumwf->fRefTime;
         //}
         //gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = cftime + sumwf->fRefTime;

         if (sumwf->fIsSiPM) {
            //pParameters->SetClusterSeedPeakTimeInnerAt(iInnerCL, cftime + sumwf->fRefTime);
            pParameters->SetClusterSeedPeakTimeInnerAt(iInnerCL, gamma->fvT[sumwf->fIsSiPM ? 0 : 1]);
            pParameters->SetClusterSeedBaselineInnerAt(iInnerCL, baseline);
            pParameters->SetClusterSeedPeakHeightInnerAt(iInnerCL, -(pkampl - baseline));
            iInnerCL++;
         } else {
            //pParameters->SetClusterSeedPeakTimeOuterAt(iOuterCL, cftime + sumwf->fRefTime);
            pParameters->SetClusterSeedPeakTimeOuterAt(iOuterCL, gamma->fvT[sumwf->fIsSiPM ? 0 : 1]);
            pParameters->SetClusterSeedBaselineOuterAt(iOuterCL, baseline);
            pParameters->SetClusterSeedPeakHeightOuterAt(iOuterCL, -(pkampl - baseline));
            iOuterCL++;
         }

         // Update fE and fT. If fT is invalid, this cluster is invalid.
         if (!gamma->fInverted) {
            gamma->fE = gamma->fvE[sumwf->fIsSiPM ? 0 : 1];
            //gamma->fT = gamma->fvT[sumwf->fIsSiPM ? 0 : 1];
         }
         if (gamma->fT > 0 * MEG::second) {
            gamma->fInvalid = kTRUE;
         }
      } // end of sumwf loop

   } // end of cluster gamma loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FindPileupGammaByFitting(MEGTXECPileupUnfolding::ClusterGamma* gamma, const Int_t sw)
{
   // Not reviewed on December 2023 because this method is not used in 2021+2022 analysis.

   for (auto sumwf : gamma->fvSumWF) {
      if (!sumwf->fvPM.size()) {
         continue;
      }
      if (!sumwf->fvPulse.size()) {
         Report(R_WARNING, "No pulse is found. Fit main gamma beforehand.");
         return;
      }

      const Int_t nPulseIni = (Int_t)sumwf->fvPulse.size();

      switch (sw) {
      case kFitOnTime:
         FitPileupGammaOnTime(sumwf);
         break;
      case kFitInBaselineRegion:
         FitPileupGammaInBaselineRegion(sumwf);
         break;
      case kFitInChargeIntegrationRegion:
         FitPileupGammaInChargeIntegrationRegion(sumwf);
         break;
      default:
         break;
      }

      // add new candidates if new pulse is found in each cluster
      for (Int_t iPulse = nPulseIni; iPulse < (Int_t)sumwf->fvPulse.size(); iPulse++) {
         fvClusterGamma.push_back(new ClusterGamma(fvClusterGamma.size()));
         fvClusterGamma.back()->fMode = gamma->fMode;
         fvClusterGamma.back()->fvMode = gamma->fvMode;
         fvClusterGamma.back()->fClusterid = gamma->fClusterid;
         fvClusterGamma.back()->fClusteridMap = gamma->fClusteridMap;
         fvClusterGamma.back()->fIsMainInCluster = false;
         fvClusterGamma.back()->fvSumWF.resize(gamma->fvSumWF.size());
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1] = new SumWF(SumWF::kClusterSumWF, (Int_t)fvClusterSumWF.size(), sumwf->fIsSiPM, sumwf->fType, sumwf->fResWaveform);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fRefTime = sumwf->fRefTime;
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fTemplateWF = FindTemplateWF(sumwf->fType);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fvPM = sumwf->fvPM;
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 1 : 0] = new SumWF(SumWF::kClusterSumWF, (Int_t)fvClusterSumWF.size(), sumwf->fIsSiPM, sumwf->fIsSiPM ? TemplateWF::kPMT : TemplateWF::kSiPM);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 1 : 0]->fRefTime = sumwf->fRefTime;
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 1 : 0]->fTemplateWF = FindTemplateWF(sumwf->fIsSiPM ? TemplateWF::kPMT : TemplateWF::kSiPM);
         fvClusterGamma.back()->fvPM = sumwf->fvPM;
         fvClusterGamma.back()->fUVW = gamma->fUVW;
         fvClusterGamma.back()->fT = sumwf->fvPulse[iPulse]->fT + sumwf->fRefTime;
         fvClusterGamma.back()->fvT.resize(gamma->fvSumWF.size());
         fvClusterGamma.back()->fvT[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse[iPulse]->fT + sumwf->fRefTime;
         fvClusterGamma.back()->fvT[sumwf->fIsSiPM ? 1 : 0] = 1e10 * second;
         fvClusterGamma.back()->fvE.resize(gamma->fvSumWF.size());
         fvClusterGamma.back()->fvE[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvPulse[iPulse]->fE;
         fvClusterGamma.back()->fvE[sumwf->fIsSiPM ? 1 : 0] = 0;
         for (auto sumwf2 : fvClusterGamma.back()->fvSumWF) {
            fvClusterSumWF.push_back(sumwf2);
         }
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::FindPileupGammaByPeakSearch(MEGTXECPileupUnfolding::ClusterGamma* gamma)
{
   // Not reviewed on December 2023 because this method is not used in 2021+2022 analysis.

   Double_t tstart, tend;
   Double_t baseline, charge;
   Double_t cfamplitude, cftime, pktime;
   Double_t pkSearchMargin[2] = {50 * nanosecond, 30 * nanosecond}; // temporary
   for (auto sumwf : gamma->fvSumWF) {
      if (!sumwf->fvPM.size()) {
         continue;
      }
      if (!sumwf->fvPulse.size()) {
         Report(R_WARNING, "No pulse is found. Fit main gamma beforehand.");
         return;
      }
      FitPileupGammaInBaselineRegion(sumwf);// Remove Pileup in baseline

      MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);

      std::map<Double_t, Int_t, std::less<Double_t>> vPeak; // peak point, amplitude
      sumwf->PeakSearchInRes({sumwf->fSumWaveform->GetTimeMin() + 15 * nanosecond,
                              TMath::Min(sumwf->fSumWaveform->GetTimeMax(),
                                         wfrh->GetChargeIntEnd() + pkSearchMargin[sumwf->fIsSiPM ? 0 : 1])},
                             vPeak);

      // add new candidates if no less than one pulse is found in each cluster
      if (vPeak.size()) {
         auto peak = vPeak.begin(); //only largest gamma
         pktime = sumwf->fResWaveform->GetTimeAt(peak->second);
         fvClusterGamma.push_back(new ClusterGamma(fvClusterGamma.size()));
         fvClusterGamma.back()->fMode = gamma->fMode;
         fvClusterGamma.back()->fvMode = gamma->fvMode;
         fvClusterGamma.back()->fClusterid = gamma->fClusterid;
         fvClusterGamma.back()->fClusteridMap = gamma->fClusteridMap;
         fvClusterGamma.back()->fvSumWF.resize(gamma->fvSumWF.size());
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1] = new SumWF(SumWF::kClusterSumWF, (Int_t)fvClusterSumWF.size(), sumwf->fIsSiPM, sumwf->fResWaveform, sumwf->fType);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fRefTime = sumwf->fRefTime;
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fTemplateWF = FindTemplateWF(sumwf->fType);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fvPM = sumwf->fvPM;
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 1 : 0] = new SumWF(SumWF::kClusterSumWF, (Int_t)fvClusterSumWF.size(), sumwf->fIsSiPM, sumwf->fIsSiPM ? fvTemplateType[TemplateWF::kPMT] : fvTemplateType[TemplateWF::kSiPM]);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 1 : 0]->fTemplateWF = FindTemplateWF(sumwf->fIsSiPM ? fvTemplateType[TemplateWF::kPMT] : fvTemplateType[TemplateWF::kSiPM]);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 1 : 0]->fRefTime = sumwf->fRefTime;
         fvClusterGamma.back()->fvPM = sumwf->fvPM;
         fvClusterGamma.back()->fUVW = gamma->fUVW;
         fvClusterGamma.back()->fvE.resize(gamma->fvSumWF.size());

         /* ------------- Baseline Calculation----------------*/
         tstart = TMath::Max(sumwf->fResWaveform->GetTimeAt(peak->second) + wfrh->GetBaselineStart(),
                             sumwf->fResWaveform->GetTimeMin() + 15 * nanosecond);
         tend = sumwf->fResWaveform->GetTimeAt(peak->second) + wfrh->GetBaselineEnd();
         baseline = sumwf->fResWaveform->CalculateBaseline(tstart, tend);

         /* ------------- Charge integration----------------*/
         tstart = TMath::Max(sumwf->fResWaveform->GetTimeAt(peak->second) + wfrh->GetChargeIntStart(),
                             sumwf->fResWaveform->GetTimeMin() + 15 * nanosecond);
         tend = sumwf->fResWaveform->GetTimeAt(peak->second) + wfrh->GetChargeIntEnd();
         charge = sumwf->fResWaveform->ChargeIntegration(tstart, tend, baseline);
         fvClusterGamma.back()->fvE[sumwf->fIsSiPM ? 0 : 1] = -charge;
         fvClusterGamma.back()->fvE[sumwf->fIsSiPM ? 1 : 0] = 0;

         /* ------------- Timing extraction----------------*/
         cfamplitude = (peak->first - baseline) * kConstantFraction + baseline;
         cftime = fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fSumWaveform->ConstantFraction(
                     cfamplitude,
                     peak->first * 0.9,
                     sumwf->fResWaveform->GetTimeAt(peak->second) - 150 * nanosecond,
                     sumwf->fResWaveform->GetTimeAt(peak->second) + 20 * nanosecond,
                     -1, "CUBIC");
         if (TMath::Abs(cftime - pktime) > 100 * nanosecond) {
            cftime = pktime - 30 * nanosecond;
         }
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fSumWaveform->TimeShift(-cftime);
         fvClusterGamma.back()->fvSumWF[sumwf->fIsSiPM ? 0 : 1]->fRefTime = sumwf->fRefTime + cftime;
         fvClusterGamma.back()->fT = cftime + sumwf->fRefTime;
         fvClusterGamma.back()->fvT.resize(gamma->fvSumWF.size());
         fvClusterGamma.back()->fvT[sumwf->fIsSiPM ? 0 : 1] = cftime + sumwf->fRefTime;
         fvClusterGamma.back()->fvT[sumwf->fIsSiPM ? 1 : 0] = 1e10 * second;

         for (auto sumwf2 : fvClusterGamma.back()->fvSumWF) {
            fvClusterSumWF.push_back(sumwf2);
         }
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::PeakSearchInClusterGamma(MEGTXECPileupUnfolding::ClusterGamma* gamma, const Bool_t addGamma)
{
   // Peak search for ClusterGamma based on the selected method.
   // Detected peaks are analyzed and then charge and timing are calculated.
   // Parameters in ClusterGamma are updated in case of main peak.
   // New ClusterGamma is added if this is not main and addGamma is true.

   const Int_t sw = GetSP()->GetClusterAnalysis()->GetPeakSearchMethod();
   const Double_t kCoincidenceWindow = gAnalyzer->GetXECPileupUnfoldingParameters()->GetCoincidenceWindow();
   const Double_t kTimeOffset[2] = {0 * MEG::nanosecond, 0 * MEG::nanosecond};
   Double_t pkSearchMargin[2] = {50 * MEG::nanosecond, 30 * MEG::nanosecond}; // temporary

   Int_t pkpoint;
   Double_t tstart, tend;
   Double_t baseline, charge;
   Double_t cfamplitude, cftime, pktime, pkampl;
   MEGXECDRSWaveform* wftmp;
   for (auto sumwf : gamma->fvSumWF) {
      if (sumwf->fvPM.size() == 0) {
         gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = MEGWaveform::kInvalidTime;
         gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = 0;
         continue;
      }
      MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);

      // Peak search depending on method switch
      std::map<Int_t, Double_t> vPeak; // peak point, amplitude
      tstart = sumwf->fSumWaveform->GetTimeMin() + 15 * MEG::nanosecond;
      tend = TMath::Min(sumwf->fSumWaveform->GetTimeMax() - 50 * MEG::nanosecond,
                        wfrh->GetChargeIntEnd() + pkSearchMargin[sumwf->fIsSiPM ? 0 : 1]);
      switch (sw) {
      case kSearchInMVA:
         sumwf->PeakSearchInMVA({tstart, tend}, vPeak);
         wftmp = sumwf->fMVAWaveform;
         break;
      case kSearchInDiff:
      default:
         sumwf->PeakSearchInDiff({tstart, tend}, vPeak);
         wftmp = sumwf->fDiffWaveform;
         break;
      case kSearchInDiffMVA:
         sumwf->PeakSearchInDiff({tstart, tend}, vPeak);
         wftmp = sumwf->fDiffWaveform;
         if (sumwf->fPeakSearchThreshold < -0.95) { // too noisy
            sumwf->PeakSearchInMVA({tstart, tend}, vPeak);
            wftmp = sumwf->fMVAWaveform;
         }
         break;
      }

      // Sort by absolute timing
      const Int_t nPeak = static_cast<Int_t>(vPeak.size());
      std::vector<std::pair<Double_t, Int_t>> vTemp(nPeak);
      Int_t iPeak = 0;
      for (auto peak : vPeak) {
         vTemp[iPeak++] = std::make_pair(TMath::Abs(wftmp->GetTimeAt(peak.first) + sumwf->fRefTime - gamma->fT), peak.first);
      }
      std::sort(vTemp.begin(), vTemp.end());

      if (!nPeak && addGamma) {
         // In case no pulse is found accidentally for the second call, just skip
         if (fPrint) {
            std::cout << "No pulse found in cluster WF" << std::endl;
         }

         if (!gamma->fInverted) { // If in baseline region, peak search can fail.
            gamma->fInvalid = true;
         }
         gamma->fNoPulse = true;
      }

      // Calculate timing and charge for found peaks
      for (iPeak = 0; iPeak < nPeak; iPeak++) {
         pkpoint = vTemp[iPeak].second;

         pktime = wftmp->GetTimeAt(pkpoint);
         sumwf->fSumWaveform->MinimumPeak(pkampl, pkpoint, pktime - 10 * MEG::nanosecond, pktime + 30 * MEG::nanosecond);
         pktime = sumwf->fSumWaveform->GetTimeAt(pkpoint);

         // baseline is already subtracted when sumwf was made
         baseline = 0;

         /* ------------- Charge integration----------------*/
         tstart = TMath::Max(pktime + wfrh->GetChargeIntStart(),
                             sumwf->fSumWaveform->GetTimeMin() + 15 * MEG::nanosecond);
         tend = pktime + wfrh->GetChargeIntEnd();
         // Check the neighbor pulses
         for (Int_t jPeak = 0; jPeak < nPeak; jPeak++) {
            if (jPeak == iPeak) {
               continue;
            }
            Double_t pktime_tmp = sumwf->fSumWaveform->GetTimeAt(vTemp[jPeak].second);
            if (pktime_tmp < pktime) { // earlier
               tstart = TMath::Max(tstart, pktime_tmp + wfrh->GetChargeIntEnd() / 2);
            } else {
               tend = TMath::Min(tend, pktime_tmp + wfrh->GetChargeIntStart() / 2);
            }
         }
         charge = sumwf->fSumWaveform->ChargeIntegration(tstart, tend, baseline);

         /* ------------- Timing extraction----------------*/
         cfamplitude = (pkampl - baseline) * kConstantFraction + baseline;
         cftime = sumwf->fSumWaveform->ConstantFraction(
                     cfamplitude,
                     pkampl * 0.9,
                     pktime - 100 * MEG::nanosecond,
                     pktime + 20 * MEG::nanosecond,
                     -1, "CUBIC");
         if (TMath::Abs(cftime - pktime) > 100 * MEG::nanosecond) {
            cftime = pktime - 30 * MEG::nanosecond;
         }
         cftime += sumwf->fRefTime + kTimeOffset[sumwf->fIsSiPM ? 0 : 1];

         // Update parameters or add new ClusterGamma
         if (iPeak == 0 && TMath::Abs(gamma->fvT[sumwf->fIsSiPM ? 0 : 1] - cftime) < kCoincidenceWindow) {
            // FIXME: coincidence here?
            // Update parameter
            auto sumwf2 = FindSumWF(sumwf->fType);
            gamma->fvE[sumwf->fIsSiPM ? 0 : 1] = -charge * sumwf->fNormCharge / sumwf2->fNormCharge;
            gamma->fvT[sumwf->fIsSiPM ? 0 : 1] = cftime;
         } else if (gamma->fvT[sumwf->fIsSiPM ? 0 : 1] < 0 && addGamma) { // new candidate
            auto gamma2 = new ClusterGamma(fvClusterGamma.size());
            gamma2->fMode  = gamma->fMode;
            gamma2->fvMode = gamma->fvMode;
            gamma2->fClusterid    = gamma->fClusterid;
            gamma2->fClusteridMap = gamma->fClusteridMap;
            gamma2->fIsMainInCluster = false;
            gamma2->fvSumWF.resize(gamma->fvSumWF.size());
            gamma2->fvSumWF[sumwf->fIsSiPM ? 0 : 1] = gamma->fvSumWF[sumwf->fIsSiPM ? 0 : 1];

            fvClusterSumWF.push_back(new SumWF(SumWF::kClusterSumWF, (Int_t)fvClusterSumWF.size(), !sumwf->fIsSiPM,
                                               sumwf->fIsSiPM ? fvTemplateType[TemplateWF::kPMT] : fvTemplateType[TemplateWF::kSiPM]));
            gamma2->fvSumWF[sumwf->fIsSiPM ? 1 : 0] = fvClusterSumWF.back();
            gamma2->fvSumWF[sumwf->fIsSiPM ? 1 : 0]->fTemplateWF = FindTemplateWF(sumwf->fIsSiPM ? fvTemplateType[TemplateWF::kPMT] : fvTemplateType[TemplateWF::kSiPM]);
            gamma2->fvSumWF[sumwf->fIsSiPM ? 1 : 0]->fRefTime = sumwf->fRefTime;
            gamma2->fvPM = gamma->fvPM;
            gamma2->fUVW = gamma->fUVW;

            gamma2->fvE.resize(gamma->fvE.size());
            gamma2->fvT.resize(gamma->fvT.size());
            auto sumwf2 = FindSumWF(sumwf->fType);
            gamma2->fvE[sumwf->fIsSiPM ? 0 : 1] = -charge * sumwf->fNormCharge / sumwf2->fNormCharge;
            gamma2->fvE[sumwf->fIsSiPM ? 1 : 0] = 0;
            gamma2->fvT[sumwf->fIsSiPM ? 0 : 1] = cftime;
            gamma2->fvT[sumwf->fIsSiPM ? 1 : 0] = MEGWaveform::kInvalidTime;
            gamma2->fT = cftime;

            fvClusterGamma.push_back(gamma2);
         } // end of updating parameters or add new ClusterGamma
      } // end of peak loop

   } // end of sumwf loop
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::MergeClusterGamma(const Bool_t addPM, const Int_t method)
{
   // Merge ClusterGamma.

   const Int_t nGamma = static_cast<Int_t>(fvClusterGamma.size());
   UnionFindTree uft;
   uft.Init(nGamma);

   // Merge gammas with same mode
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      ClusterGamma* gamma = fvClusterGamma[iGamma];
      if (gamma->fInvalid) {
         continue;
      }

      for (Int_t jGamma = iGamma + 1; jGamma < nGamma; jGamma++) {
         ClusterGamma* gamma2 = fvClusterGamma[jGamma];
         if (gamma2->fInvalid) {
            continue;
         }
         Bool_t sameMode = false;
         for (auto mode : gamma->fvMode) {
            for (auto mode2 : gamma2->fvMode) {
               if (mode == mode2) {
                  sameMode = true;
               }
            }
         }
         if (!sameMode) {
            continue;
         }
         if (IsSameGamma(gamma, gamma2, method)) {
            uft.Unit(iGamma, jGamma);
         }
      } // end of jGamma loop
   } // end of iGamma loop

   // Merge gammas with different mode
   std::vector<std::pair<Double_t, std::pair<Int_t, Int_t> > > vCandidate;
   std::vector<Int_t> vModeCache[nGamma];
   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      ClusterGamma* gamma = fvClusterGamma[iGamma];
      if (gamma->fInvalid) {
         continue;
      }
      for (auto mode : gamma->fvMode) {
         vModeCache[iGamma].push_back(mode);
      }

      for (Int_t jGamma = iGamma + 1; jGamma < nGamma; jGamma++) {
         ClusterGamma* gamma2 = fvClusterGamma[jGamma];
         if (gamma2->fInvalid) {
            continue;
         }
         Bool_t sameMode = false;
         for (auto mode : gamma->fvMode) {
            for (auto mode2 : gamma2->fvMode) {
               if (mode == mode2) {
                  sameMode = true;
               }
            }
         }
         if (sameMode) {
            continue;
         }
         if (IsSameGamma(gamma, gamma2, method)) {
            vCandidate.push_back(std::make_pair(TMath::Abs(gamma->fT - gamma2->fT), std::make_pair(iGamma, jGamma)));
         }
      } // end of jGamma loop
   } // end of iGamma loop

   std::sort(vCandidate.begin(), vCandidate.end());
   for (auto candidate : vCandidate) {
      Int_t iGamma = candidate.second.first;
      Int_t jGamma = candidate.second.second;
      Bool_t mergedMode = false;
      for (auto mode : vModeCache[jGamma]) {
         if (std::find(vModeCache[iGamma].begin(), vModeCache[iGamma].end(), mode) != vModeCache[iGamma].end()) {
            mergedMode = true;
         }
      }
      if (!mergedMode) {
         // Merge with the nearest candidate in the mode
         uft.Unit(iGamma, jGamma);
         for (auto mode : vModeCache[jGamma]) {
            vModeCache[iGamma].push_back(mode);
         }
         for (auto mode : vModeCache[iGamma]) {
            vModeCache[jGamma].push_back(mode);
         }
      }
   }
   for (auto candidate : vCandidate) {
      Int_t iGamma = candidate.second.first;
      Int_t jGamma = candidate.second.second;
      if (candidate.first < 1 * MEG::nanosecond) {
         uft.Unit(iGamma, jGamma);
      }
   }

   for (Int_t iGamma = 0; iGamma < nGamma; iGamma++) {
      ClusterGamma* gamma = fvClusterGamma[iGamma];
      if (gamma->fInvalid) {
         continue;
      }

      for (Int_t jGamma = iGamma + 1; jGamma < nGamma; jGamma++) {
         ClusterGamma* gamma2 = fvClusterGamma[jGamma];
         if (gamma2->fInvalid) {
            continue;
         }

         if (uft.IsSame(iGamma, jGamma)) {
            MergeGamma(gamma, gamma2, addPM);
         }
      } // end of jGamma loop
   } // end of iGamma loop
}

//______________________________________________________________________________
Bool_t MEGTXECPileupUnfolding::IsSameGamma(ClusterGamma* gamma, ClusterGamma* gamma2, const Int_t method)
{
   // Judge if two ClusterGammas are the same or not.
   // (Overlapped PMs fraction and time difference) and/or distance are used based on switch.

   if (!gamma->fvPM.size() || !gamma2->fvPM.size()) {
      return false;
   }
   if (gamma->fMode > gamma2->fMode) {
      return IsSameGamma(gamma2, gamma);
   }

   Float_t kThresholdDistance = 6.3 * MEG::centimeter * 3; // from MEG
   const Float_t kThresholdOverlap = 0.5; // from MEG
   const Float_t kThresholdTime = 10 * MEG::nanosecond;

   Double_t dT = TMath::Abs(gamma->fT - gamma2->fT);
   Float_t d = TMath::Sqrt((gamma->fUVW[0] - gamma2->fUVW[0]) * (gamma->fUVW[0] - gamma2->fUVW[0]) +
                           (gamma->fUVW[1] - gamma2->fUVW[1]) * (gamma->fUVW[1] - gamma2->fUVW[1]));

   // Overlaped PM fraction calculation
   Float_t overlap = 0; // Number of overlaped PMs in cluster / Number of PMs in cluster
   if (gamma->fMode != gamma2->fMode) { // found by different approaches
      if (gamma->fMode == ClusterGamma::kLDInner
          && gamma2->fMode == ClusterGamma::kLDOuter) {
         kThresholdDistance *= 1.7; // FIXME: Why scaled by 1.7?
         overlap = 0;
      } else { // LD (single face) and TD (multiple face)
         Float_t count = 0;
         Int_t face = gamma->fMode;
         for (auto pm2 : gamma2->fvPM) {
            if (gAnalyzer->GetXECPMRunHeaderAt(pm2)->GetFace() == face) {
               // Consider only PMs in the same face
               for (auto pm : gamma->fvPM) {
                  if (pm == pm2) { // included
                     overlap += 1;
                     break;
                  }
               }
               count += 1;
            }
         }
         if (count > 0) {
            overlap /= count;
         }
      }
   } else { // found by the same approaches
      if (gamma->fIsMainInCluster && gamma2->fIsMainInCluster) {
         // Cannot be merged by space
         overlap = 0;
         d = 1e10 * MEG::centimeter;
      } else {
         for (auto pm : gamma->fvPM) {
            auto itr = std::find(gamma2->fvPM.begin(), gamma2->fvPM.end(), pm);
            if (itr != gamma2->fvPM.end()) { // included
               overlap += 1;
            }
         }
         overlap /= TMath::Max(gamma->fvPM.size(), gamma2->fvPM.size());
      }
   }

   switch (method) {
   case ClusterGamma::kSpaceBasedMerge:
      if (d < kThresholdDistance || overlap > kThresholdOverlap) {
         return true;
      }
      break;
   case ClusterGamma::kTimingBasedMerge:
      if (dT < kThresholdTime) {
         return true;
      }
      break;
   case ClusterGamma::kSpaceAndTimingBasedMerge:
   default:
      if ((d < kThresholdDistance || overlap > kThresholdOverlap) && dT < kThresholdTime) {
         return true;
      }
      break;
   }

   return false;
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::MergeGamma(ClusterGamma* gamma, ClusterGamma* gamma2, const Bool_t addPM)
{
   // Merge ClusterGamma.
   // If addPM is true, clustered PMs are also added.

   if (gamma->fIndex > gamma2->fIndex) {
      MergeGamma(gamma2, gamma, addPM);
      return;
   }

   gamma2->fIndex   = gamma->fIndex;
   gamma2->fInvalid = true;
   for (Int_t i = 0; i < (Int_t)gamma2->fvT.size(); i++) {
      if (gamma->fvT[i] > 0 && gamma2->fvT[i] < 0) { // if gamma time is invalid and gamma2 time is valid
         gamma->fvT[i] = gamma2->fvT[i];
      }
   }
   for (auto mode : gamma2->fvMode) {
      if (std::find(gamma->fvMode.begin(), gamma->fvMode.end(), mode) == gamma->fvMode.end()) {
         gamma->fvMode.push_back(mode);
      }
   }

   if (addPM) {
      for (auto mode : gamma2->fvMode) {
         for (auto clusterid : gamma2->fClusteridMap[mode]) {
            if (std::find(gamma->fClusteridMap[mode].begin(), gamma->fClusteridMap[mode].end(), clusterid)
                == gamma->fClusteridMap[mode].end()) {
               gamma->fClusteridMap[mode].push_back(clusterid);
            }
         }
      }
      for (auto pm : gamma2->fvPM) {
         if (std::find(gamma->fvPM.begin(), gamma->fvPM.end(), pm) == gamma->fvPM.end()) {
            gamma->fvPM.push_back(pm);
            gamma->fvSumWF[gAnalyzer->GetXECPMRunHeaderAt(pm)->GetIsSiPM() ? 0 : 1]->fvPM.push_back(pm);
         }
      }
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::CombineRecCluster()
{
   // Check if on-time ClusterGamma exists.
   // Switch is implemented depending on fitting method.
   // In the case of independent fit,
   //   an event with multiple clusters within coincidence window is a "coincident" event.
   // In the case of simultaneous fit,
   //   an event with the larger number of clusters than that of pulses within a coincidence window is a "coincident" event.

   auto pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();
   if (!pParameters->GetSimultaneousFitFlag()) {
      // Connect main gamma
      for (auto gamma_cl : fvClusterGamma) {
         if (gamma_cl->fIsMain) { // gamma: Main Gamma Cluster
            fvRecGamma[0]->fUVW = gamma_cl->fUVW;
            break;
         }
      }

      // Check On-time pileup
      // Double_t mindistance = 1000;
      for (auto gamma : fvClusterGamma) {
         if (!gamma->fIsMain) { // gamma: Main Gamma Cluster
            continue;
         }
         for (auto gamma2 : fvClusterGamma) {
            if (gamma2->fIsMain || gamma2->fInvalid || gamma->fIndex == gamma2->fIndex) { // gamma2: another valid gamma
               continue;
            }
            Bool_t sameMode = false;
            for (auto mode : gamma->fvMode) {
               for (auto mode2 : gamma2->fvMode) {
                  if (mode == mode2) {
                     sameMode = true;
                  }
               }
            }
            Bool_t sameCluster = false;
            if (std::find(gamma->fClusteridMap[gamma2->fMode].begin(), gamma->fClusteridMap[gamma2->fMode].end(), gamma2->fClusterid)
                  != gamma->fClusteridMap[gamma2->fMode].end()) { // see primary
               sameCluster = true;
            }
            Bool_t sameTiming = false;
            if (TMath::Abs(gamma->fT - gamma2->fT) < pParameters->GetCoincidenceWindow()) {
               sameTiming = true;
            }
            if (fPrint) {
               std::cout << "SameMode: " << sameMode << " SameTiming: " << sameTiming << " SameCluster: " << sameCluster << std::endl;
            }
            if (sameMode
                  && !sameCluster
                  && sameTiming
                  && gamma2->fIsMainInCluster) {
               // Add on-time pileup
               //fvRecGamma.push_back(new RecGamma(fvRecGamma.size(), kClusterGamma, gamma2->fIndex));
               fvRecGamma.push_back(new RecGamma(fvRecGamma.size(), kClusterGamma, fvRecGamma.size()));
               fvRecGamma.back()->fUVW = gamma2->fUVW;
               fvRecGamma.back()->Resize(gamma2->fvSumWF.size());
               Double_t distance = TMath::Sqrt(TMath::Power(gamma->fUVW[0] - gamma2->fUVW[0], 2) +
                                               TMath::Power(gamma->fUVW[1] - gamma2->fUVW[1], 2));
               fvRecGamma.back()->fDistanceToMain = distance;
               for (auto sumwf : gamma->fvSumWF) {
                  fvRecGamma.back()->fvNormCharge[sumwf->fIsSiPM ? 0 : 1] = sumwf->fNormCharge;
                  fvRecGamma.back()->fvE[sumwf->fIsSiPM ? 0 : 1] = 0;
                  fvRecGamma.back()->fvT[sumwf->fIsSiPM ? 0 : 1] = gamma2->fT;
                  fvRecGamma.back()->fvFitStatus[sumwf->fIsSiPM ? 0 : 1] = sumwf->fFitStatus;
                  fvRecGamma.back()->fvGammaType[sumwf->fIsSiPM ? 0 : 1] = RecGamma::kCoincidencePL;
                  fvRecGamma.back()->fvSaturatedCh[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvSaturatedCh;
                  fvRecGamma.back()->fvDeadCh[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvDeadCh;
               }
            } // end if same
         } // end of gamma2 loop
      } // end of gamma loop
   } else {
      // On-time pileup event is defined as an event
      //  having the larger number of cluster gammas than that of pulses in coincidence time window.
      // Surplus cluster gammas are added in RecGamma.

      // Search for unused inner clusters
      Bool_t flagUsed(kFALSE);
      const Int_t NPulse = static_cast<Int_t>(fvRecGamma.size());
      for (auto clgamma : fvClusterGamma) {
         flagUsed = kFALSE;
         if (clgamma->fMode != ClusterGamma::kLDInner ||
               TMath::Abs(clgamma->fT - fvRecGamma[0]->fvT[TemplateWF::kSiPM]) > pParameters->GetCoincidenceWindow()) {
            clgamma->fInvalid = kTRUE;
            continue;
         }

         for (Int_t iGamma = 0; iGamma < NPulse; iGamma++) {
            if (fvRecGamma[iGamma]->fvPulse[TemplateWF::kSiPM]->fGammaIndex[kClusterGamma] == clgamma->fIndex) {
               flagUsed = kTRUE;
               break;
            }
         }
         if (flagUsed) {
            clgamma->fIsAssociatedWithPulse = kTRUE;
            continue;
         }
      } // end of cluster gamma loop

      Int_t minIdx;
      Double_t dt, minDt;
      for (Int_t iGamma = 1; iGamma < NPulse; iGamma++) {
         minIdx = -1;
         minDt  = MEGWaveform::kInvalidTime;
         for (auto clgamma : fvClusterGamma) {
            if (clgamma->fInvalid || clgamma->fIsMain || clgamma->fIsAssociatedWithPulse) {
               continue;
            }
            dt = TMath::Abs(fvRecGamma[iGamma]->fvT[TemplateWF::kSiPM] - clgamma->fT);
            if (dt < minDt) {
               minDt = dt;
               minIdx = clgamma->fIndex;
            }
         }
         if (fPrint) {
            std::cout << "iGamma " << iGamma << " clusterGammaIndex " << minIdx << " minDt " << minDt << std::endl;
         }
         if (minIdx > -1 && minDt < pParameters->GetClusterCoincWindow()) {
            fvRecGamma[iGamma]->fUVW = fvClusterGamma[minIdx]->fUVW;
            fvClusterGamma[minIdx]->fIsAssociatedWithPulse = kTRUE;
         }
      } // end of RecGamma loop

      for (auto clgamma : fvClusterGamma) {
         if (clgamma->fInvalid || clgamma->fIsMain || clgamma->fIsAssociatedWithPulse) { // used before
            continue;
         }

         // Additional RecGamma
         fvRecGamma.push_back(new RecGamma(fvRecGamma.size(), kClusterGamma, clgamma->fIndex));
         fvRecGamma.back()->fUVW = clgamma->fUVW;
         fvRecGamma.back()->fDistanceToMain = TMath::Sqrt(TMath::Power(clgamma->fUVW[0] - fvRecGamma[0]->fUVW[0], 2) +
                                                          TMath::Power(clgamma->fUVW[1] - fvRecGamma[0]->fUVW[1], 2));
         fvRecGamma.back()->Resize(clgamma->fvSumWF.size());

         for (auto sumwf : clgamma->fvSumWF) {
            fvRecGamma.back()->fvNormCharge[sumwf->fIsSiPM ? 0 : 1] = sumwf->fNormCharge;
            fvRecGamma.back()->fvE[sumwf->fIsSiPM ? 0 : 1] = 0;
            fvRecGamma.back()->fvT[sumwf->fIsSiPM ? 0 : 1] = clgamma->fT;
            fvRecGamma.back()->fvFitStatus[sumwf->fIsSiPM ? 0 : 1] = sumwf->fFitStatus;
            fvRecGamma.back()->fvGammaType[sumwf->fIsSiPM ? 0 : 1] = RecGamma::kCoincidencePL;
            fvRecGamma.back()->fvSaturatedCh[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvSaturatedCh;
            fvRecGamma.back()->fvDeadCh[sumwf->fIsSiPM ? 0 : 1] = sumwf->fvDeadCh;
         }
      } // end of cluster gamma loop

   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::AnalyzeFADCWF()
{
   // Signal timing and size is extracted using FADC Qsum waveforms for trigger.
   // Number of peaks, Qpmt timing, and Qpmt height are calculated with Qpmt waveform.
   // Then, Qmppc timing and Qmppc height are calculated based on Qpmt information.

   const Int_t    kPeakMax = 20;
   const Double_t kCFFraction = 0.2;
   const Double_t kTimeMin[2] = {-500 * MEG::nanosecond, -700 * MEG::nanosecond};
   std::vector<Double_t> vAmpl;
   std::vector<Int_t> vPnt;
   MEGXECDRSWaveform* wf[2]; // MPPC and PMT

   Double_t pktime, cftime, baseline, cfamplitude;

   std::vector<SeedGamma*> vGamma;
   MEGXECWFRunHeader* wfrh;
   auto* pParameters = gAnalyzer->GetXECPileupUnfoldingParameters();

   /*------------- Make FADC Qsum waveform ----------------*/
   for (auto sumwf : fvTotalSumWF) {
      Int_t npnt = fvFADCQsumWaveform[sumwf->fIndex]->GetNPoints();
      if (!npnt) {
         Report(R_WARNING, "No FADC Qsum waveform data is stored. Skip FADC Qsum waveform analysis.");
         return;
      }
      wf[sumwf->fIndex] = new MEGXECDRSWaveform();
      wf[sumwf->fIndex]->SetNPoints(kFADCNBins);
      wf[sumwf->fIndex]->SetTime(kFADCTimeMin, 0);
      for (Int_t ibin = 0; ibin < kFADCNBins; ++ibin) {
         wf[sumwf->fIndex]->SetAmplitudeAt(kFADCNBins - ibin - 1,
                                           fvFADCQsumWaveform[sumwf->fIndex]->GetAmplitudeAt(npnt - ibin - 1));
      }
      wf[sumwf->fIndex]->MovingAverage(3, sumwf->fFADCQsumWaveform, 0, kFADCNBins, kFALSE, kTRUE);
   } // end of MPPC and PMT loop

   /*------------- Qpmt waveform analysis ----------------*/
   vAmpl.clear();
   vAmpl.resize(kPeakMax);
   vPnt.clear();
   vPnt.resize(kPeakMax);

   wfrh = gAnalyzer->GetXECWFRunHeaderAt(TemplateWF::kPMT);
   Double_t threshold = pParameters->GetFADCQpmtThreshold();
   baseline = fvTotalSumWF[TemplateWF::kPMT]->fFADCQsumWaveform->CalculateBaseline(
         kFADCTimeMin + 50 * MEG::nanosecond, -50 * MEG::nanosecond,
         -threshold / 2., +threshold / 2.,
         threshold / 10., threshold / 10., threshold / 20., "M");
   Int_t nPeak = fvTotalSumWF[TemplateWF::kPMT]->fFADCQsumWaveform->PeakSearch(
         &vAmpl[0], &vPnt[0], kPeakMax,
         TMath::Max(-800 * MEG::nanosecond, kFADCTimeMin + 50 * MEG::nanosecond), // tstart
         -50 * MEG::nanosecond,                                                   // tend
         baseline + threshold, 50 * MEG::nanosecond, 1);
   nPeak = TMath::Min(nPeak, kPeakMax);
   std::vector<Double_t> vRefTime(nPeak);

   for (Int_t iPeak = 0; iPeak < nPeak; ++iPeak) {
      pktime = fvTotalSumWF[TemplateWF::kPMT]->fFADCQsumWaveform->GetTimeAt(vPnt[iPeak]);
      cfamplitude = (vAmpl[iPeak] - baseline) * kCFFraction + baseline;
      cftime = fvTotalSumWF[TemplateWF::kPMT]->fFADCQsumWaveform->ConstantFraction(
            cfamplitude, vAmpl[iPeak] * 0.9,
            pktime - 80 * MEG::nanosecond, pktime + 20 * MEG::nanosecond,
            1);
      vRefTime[iPeak] = cftime;

      if (cftime < 0) { // if cftime is valid
         vGamma.push_back(new SeedGamma(vGamma.size()));
         vGamma.back()->fSumWFIndex = TemplateWF::kPMT;
         vGamma.back()->fvE.resize(2); // SiPM and PMT
         vGamma.back()->fvT.resize(2);

         vGamma.back()->fvE[TemplateWF::kPMT] = (vAmpl[iPeak] - baseline) * pParameters->GetFADCScaleFactorAt(1);
         vGamma.back()->fvT[TemplateWF::kPMT] = cftime;
      }
   } // end of peak loop

   // Set fgFADCRefTime
   Float_t maxE(-1e10);
   for (auto gamma : vGamma) {
      if (maxE < gamma->fvE[TemplateWF::kPMT]
            && gamma->fvT[TemplateWF::kPMT] > kTimeMin[gAnalyzer->IsActiveDAQ("bartender") ? 1 : 0]) {
         maxE = gamma->fvE[TemplateWF::kPMT];
         fgFADCRefTime = gamma->fvT[TemplateWF::kPMT];
      }
   }

   // Set FADC parameter size for monitoring
   pParameters->SetFADCSeedPeakTimeSize(vGamma.size() * 2);
   pParameters->SetFADCSeedBaselineSize(vGamma.size() * 2);
   pParameters->SetFADCSeedPeakHeightSize(vGamma.size() * 2);

   // Set Qpmt baseline parameters
   for (Int_t iPeak = 1; iPeak < pParameters->GetFADCSeedPeakTimeSize(); iPeak += 2) {
      pParameters->SetFADCSeedBaselineAt(iPeak, baseline);
   }

   /*------------- Qmppc waveform analysis ----------------*/
   wfrh = gAnalyzer->GetXECWFRunHeaderAt(0);
   baseline = fvTotalSumWF[TemplateWF::kSiPM]->fFADCQsumWaveform->CalculateBaseline(
         kFADCTimeMin + 50 * MEG::nanosecond, -50 * MEG::nanosecond,
         -threshold / 2., +threshold / 2.,
         threshold / 10., threshold / 10., threshold / 20., "M");
   for (Int_t iPeak = 0; iPeak < pParameters->GetFADCSeedPeakTimeSize(); iPeak += 2) {
      pParameters->SetFADCSeedBaselineAt(iPeak, baseline);
   }

   Double_t pkampl;
   Int_t    pkpnt, iGamma(0);
   Double_t peakSearchRegion[2] = {-50 * MEG::nanosecond,
                                   100 * MEG::nanosecond};
   for (Int_t iPeak = 0; iPeak < nPeak; ++iPeak) {
      if (vRefTime[iPeak] > 0) {
         continue;
      }
      fvTotalSumWF[TemplateWF::kSiPM]->fFADCQsumWaveform->MaximumPeak(
            pkampl, pkpnt, vRefTime[iPeak] + peakSearchRegion[0], vRefTime[iPeak] + peakSearchRegion[1]);
      pktime = fvTotalSumWF[TemplateWF::kSiPM]->fFADCQsumWaveform->GetTimeAt(pkpnt);

      // Check peak time does not overlap the next pulses.
      for (Short_t jPeak = 0; jPeak < nPeak; ++jPeak) {
         if ((iPeak < jPeak && pktime > vRefTime[jPeak]) ||
             (iPeak > jPeak && pktime < vRefTime[jPeak])) {
            fvTotalSumWF[TemplateWF::kSiPM]->fFADCQsumWaveform->MaximumPeak(
                  pkampl, pkpnt, vRefTime[iPeak] + peakSearchRegion[0] / 2., vRefTime[iPeak] + peakSearchRegion[1] / 2.);
            pktime = fvTotalSumWF[TemplateWF::kSiPM]->fFADCQsumWaveform->GetTimeAt(pkpnt);
         }
      }

      cfamplitude = (pkampl - baseline) * kCFFraction + baseline;
      cftime = fvTotalSumWF[TemplateWF::kSiPM]->fFADCQsumWaveform->ConstantFraction(
            cfamplitude, pkampl * 0.9,
            pktime - 80 * MEG::nanosecond, pktime,
            1);
      if (cftime > 0) {
         cftime = vRefTime[iPeak];
      }
      cftime = vRefTime[iPeak];
      vGamma[iGamma]->fvE[TemplateWF::kSiPM] = (pkampl - baseline) * pParameters->GetFADCScaleFactorAt(0);
      vGamma[iGamma]->fvT[TemplateWF::kSiPM] = cftime;
      ++iGamma;
   } // end of peak loop

   /*------------- Set FADC waveform analysis parameters ----------------*/
   /*------------- Shift timing parameter ----------------*/
   for (iGamma = 0; iGamma < static_cast<Int_t>(vGamma.size()); ++iGamma) {
      for (Int_t iSumWF = 0; iSumWF < 2; ++iSumWF) {
         pParameters->SetFADCSeedPeakTimeAt(iGamma * 2 + iSumWF,
                                            vGamma[iGamma]->fvT[iSumWF]);
         pParameters->SetFADCSeedPeakHeightAt(iGamma * 2 + iSumWF,
                                              vGamma[iGamma]->fvE[iSumWF] / pParameters->GetFADCScaleFactorAt(iSumWF));
         vGamma[iGamma]->fvT[iSumWF] -= fgFADCRefTime;
         vGamma[iGamma]->fvT[iSumWF] += fvTotalSumWF[iSumWF]->fRefTime;
      }
   }

   for (auto gamma : vGamma) {
      if (!gamma->fInvalid) {
         fvFADCGamma.push_back(gamma);
      } else {
         delete gamma;
      }
   }

   for (Int_t i = 0; i < 2; ++i) {
      delete wf[i];
   }
}

//______________________________________________________________________________
void MEGTXECPileupUnfolding::MakeTemplate()
{
   // Main function of make waveform template.

   for (auto sumwf : fvSumWFTmpl) {
      sumwf->fRefTime = fgRefTime;
      sumwf->MakeSumWF();
   }

   // Skip if pileup found in PMT after charge integration region
   std::map<Double_t, Int_t, std::less<Double_t>> vPeak; // amplitude, peak point
   Double_t tstart = fvSumWFTmpl[TemplateWF::kPMT]->fSumWaveform->GetTimeMin() + 15 * nanosecond;
   Double_t tend   = fvSumWFTmpl[TemplateWF::kPMT]->fSumWaveform->GetTimeMax() - 100 * nanosecond;
   fvSumWFTmpl[1]->PeakSearchInDiff({tstart, tend}, vPeak, -0.2);

   if (vPeak.size() > 1) {
      return;
   }

   Double_t binSize = gAnalyzer->GetXECRunHeader()->GetSamplingInterval();
   Int_t ipnt = -1;
   Double_t cftime = 1e10 * MEG::second;
   for (auto sumwf : fvSumWFTmpl) {
      MEGXECWFRunHeader *wfrh = gAnalyzer->GetXECWFRunHeaderAt(sumwf->fIsSiPM ? 0 : 1);
      cftime = sumwf->GetConstantFractionTime();
      if (cftime > 1e3) {
        continue;
      }
      sumwf->fSumWaveform->TimeShift(-cftime);
      Double_t baseline = sumwf->fSumWaveform->CalculateBaseline(wfrh->GetBaselineStart(), wfrh->GetBaselineEnd());
      Double_t vpeak;
      Int_t pkpoint;
      sumwf->fSumWaveform->MinimumPeak(vpeak, pkpoint, sumwf->fSumWaveform->GetTimeMin(), sumwf->fSumWaveform->GetTimeMax());
      if (vpeak >= 0) {
         continue;
      }
      for (Int_t i = 0; i < TMath::Min(sumwf->fTemplateWF->fTemplate->GetNbinsX(), sumwf->fSumWaveform->GetNPoints()); i++) {
         Double_t tbin = -120 * MEG::nanosecond + binSize * i;
         ipnt = sumwf->fSumWaveform->FindPoint(tbin);
         if (ipnt >= 0) {
            sumwf->fTemplateWF->fTemplate->Fill(i, (sumwf->fSumWaveform->GetAmplitude()[ipnt] - baseline) / (-vpeak));
         } else {
            sumwf->fTemplateWF->fTemplate->Fill(i, 0);
         }
      }
      XECMakeTemplate::AddWaveformToTemplate(sumwf->fSumWaveform,
                                             sumwf->fTemplateWF->fTemplateWaveform,
                                             sumwf->fTemplateWF->fNAdded,
                                             -kTemplateT0);
   }

   if (fDrawResult && fCanvas) {
      fStyle->cd();
      fCanvas->cd(1);
      fvSumWFTmpl[0]->fSumWaveform->Draw();
      fCanvas->cd(2);
      fvSumWFTmpl[1]->fSumWaveform->Draw();
      fCanvas->cd(3);
      fvSumWFTmpl[0]->fTemplateWF->fTemplate->Draw("colz");
      fCanvas->cd(4);
      fvSumWFTmpl[1]->fTemplateWF->fTemplate->Draw("colz");
      fCanvas->Modified();
      fCanvas->Update();
   }
}

